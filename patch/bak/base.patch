project frameworks/av/
diff --git a/frameworks/av/camera/Android.mk b/frameworks/av/camera/Android.mk
index 431f733..5fd5eb8 100644
--- a/frameworks/av/camera/Android.mk
+++ b/frameworks/av/camera/Android.mk
@@ -58,6 +58,9 @@ LOCAL_WHOLE_STATIC_LIBRARIES += $(TARGET_SPECIFIC_CAMERA_PARAMETER_LIBRARY)
 else
 LOCAL_WHOLE_STATIC_LIBRARIES += libcamera_parameters
 endif
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+	LOCAL_CFLAGS += -DQCOM_HARDWARE
+endif
 
 LOCAL_MODULE:= libcamera_client
 
diff --git a/frameworks/av/camera/CameraParameters.cpp b/frameworks/av/camera/CameraParameters.cpp
index 7ac60f2..528d115 100644
--- a/frameworks/av/camera/CameraParameters.cpp
+++ b/frameworks/av/camera/CameraParameters.cpp
@@ -21,19 +21,27 @@
 #include <string.h>
 #include <stdlib.h>
 #include <camera/CameraParameters.h>
-#include <camera/CameraParametersExtra.h>
 #include <system/graphics.h>
 
 namespace android {
 // Parameter keys to communicate between camera application and driver.
 const char CameraParameters::KEY_PREVIEW_SIZE[] = "preview-size";
 const char CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES[] = "preview-size-values";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_SUPPORTED_HFR_SIZES[] = "hfr-size-values";
+#endif
 const char CameraParameters::KEY_PREVIEW_FORMAT[] = "preview-format";
 const char CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS[] = "preview-format-values";
 const char CameraParameters::KEY_PREVIEW_FRAME_RATE[] = "preview-frame-rate";
 const char CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES[] = "preview-frame-rate-values";
 const char CameraParameters::KEY_PREVIEW_FPS_RANGE[] = "preview-fps-range";
 const char CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE[] = "preview-fps-range-values";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_PREVIEW_FRAME_RATE_MODE[] = "preview-frame-rate-mode";
+const char CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATE_MODES[] = "preview-frame-rate-modes";
+const char CameraParameters::KEY_PREVIEW_FRAME_RATE_AUTO_MODE[] = "frame-rate-auto";
+const char CameraParameters::KEY_PREVIEW_FRAME_RATE_FIXED_MODE[] = "frame-rate-fixed";
+#endif
 const char CameraParameters::KEY_PICTURE_SIZE[] = "picture-size";
 const char CameraParameters::KEY_SUPPORTED_PICTURE_SIZES[] = "picture-size-values";
 const char CameraParameters::KEY_PICTURE_FORMAT[] = "picture-format";
@@ -52,11 +60,24 @@ const char CameraParameters::KEY_GPS_PROCESSING_METHOD[] = "gps-processing-metho
 const char CameraParameters::KEY_WHITE_BALANCE[] = "whitebalance";
 const char CameraParameters::KEY_SUPPORTED_WHITE_BALANCE[] = "whitebalance-values";
 const char CameraParameters::KEY_EFFECT[] = "effect";
+const char CameraParameters::KEY_ORIENTATION[] = "orientation";
+const char CameraParameters::KEY_WATERMARK[] = "watermark";
+const char CameraParameters::KEY_MIRROR[] = "mirror";
 const char CameraParameters::KEY_SUPPORTED_EFFECTS[] = "effect-values";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_TOUCH_AF_AEC[] = "touch-af-aec";
+const char CameraParameters::KEY_SUPPORTED_TOUCH_AF_AEC[] = "touch-af-aec-values";
+const char CameraParameters::KEY_TOUCH_INDEX_AEC[] = "touch-index-aec";
+const char CameraParameters::KEY_TOUCH_INDEX_AF[] = "touch-index-af";
+#endif
 const char CameraParameters::KEY_ANTIBANDING[] = "antibanding";
 const char CameraParameters::KEY_SUPPORTED_ANTIBANDING[] = "antibanding-values";
 const char CameraParameters::KEY_SCENE_MODE[] = "scene-mode";
 const char CameraParameters::KEY_SUPPORTED_SCENE_MODES[] = "scene-mode-values";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_SCENE_DETECT[] = "scene-detect";
+const char CameraParameters::KEY_SUPPORTED_SCENE_DETECT[] = "scene-detect-values";
+#endif
 const char CameraParameters::KEY_FLASH_MODE[] = "flash-mode";
 const char CameraParameters::KEY_SUPPORTED_FLASH_MODES[] = "flash-mode-values";
 const char CameraParameters::KEY_FOCUS_MODE[] = "focus-mode";
@@ -83,6 +104,28 @@ const char CameraParameters::KEY_ZOOM_SUPPORTED[] = "zoom-supported";
 const char CameraParameters::KEY_SMOOTH_ZOOM_SUPPORTED[] = "smooth-zoom-supported";
 const char CameraParameters::KEY_FOCUS_DISTANCES[] = "focus-distances";
 const char CameraParameters::KEY_VIDEO_FRAME_FORMAT[] = "video-frame-format";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_ISO_MODE[] = "iso";
+const char CameraParameters::KEY_SUPPORTED_ISO_MODES[] = "iso-values";
+const char CameraParameters::KEY_LENSSHADE[] = "lensshade";
+const char CameraParameters::KEY_SUPPORTED_LENSSHADE_MODES[] = "lensshade-values";
+const char CameraParameters::KEY_AUTO_EXPOSURE[] = "auto-exposure";
+const char CameraParameters::KEY_SUPPORTED_AUTO_EXPOSURE[] = "auto-exposure-values";
+const char CameraParameters::KEY_DENOISE[] = "denoise";
+const char CameraParameters::KEY_SUPPORTED_DENOISE[] = "denoise-values";
+const char CameraParameters::KEY_SELECTABLE_ZONE_AF[] = "selectable-zone-af";
+const char CameraParameters::KEY_SUPPORTED_SELECTABLE_ZONE_AF[] = "selectable-zone-af-values";
+const char CameraParameters::KEY_FACE_DETECTION[] = "face-detection";
+const char CameraParameters::KEY_SUPPORTED_FACE_DETECTION[] = "face-detection-values";
+const char CameraParameters::KEY_MEMORY_COLOR_ENHANCEMENT[] = "mce";
+const char CameraParameters::KEY_SUPPORTED_MEM_COLOR_ENHANCE_MODES[] = "mce-values";
+const char CameraParameters::KEY_VIDEO_HIGH_FRAME_RATE[] = "video-hfr";
+const char CameraParameters::KEY_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES[] = "video-hfr-values";
+const char CameraParameters::KEY_REDEYE_REDUCTION[] = "redeye-reduction";
+const char CameraParameters::KEY_SUPPORTED_REDEYE_REDUCTION[] = "redeye-reduction-values";
+const char CameraParameters::KEY_HIGH_DYNAMIC_RANGE_IMAGING[] = "hdr";
+const char CameraParameters::KEY_SUPPORTED_HDR_IMAGING_MODES[] = "hdr-values";
+#endif
 const char CameraParameters::KEY_VIDEO_SIZE[] = "video-size";
 const char CameraParameters::KEY_SUPPORTED_VIDEO_SIZES[] = "video-size-values";
 const char CameraParameters::KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO[] = "preferred-preview-size-for-video";
@@ -90,9 +133,21 @@ const char CameraParameters::KEY_MAX_NUM_DETECTED_FACES_HW[] = "max-num-detected
 const char CameraParameters::KEY_MAX_NUM_DETECTED_FACES_SW[] = "max-num-detected-faces-sw";
 const char CameraParameters::KEY_RECORDING_HINT[] = "recording-hint";
 const char CameraParameters::KEY_VIDEO_SNAPSHOT_SUPPORTED[] = "video-snapshot-supported";
+const char CameraParameters::KEY_FULL_VIDEO_SNAP_SUPPORTED[] = "full-video-snap-supported";
 const char CameraParameters::KEY_VIDEO_STABILIZATION[] = "video-stabilization";
 const char CameraParameters::KEY_VIDEO_STABILIZATION_SUPPORTED[] = "video-stabilization-supported";
 const char CameraParameters::KEY_LIGHTFX[] = "light-fx";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_ZSL[] = "zsl";
+const char CameraParameters::KEY_SUPPORTED_ZSL_MODES[] = "zsl-values";
+const char CameraParameters::KEY_CAMERA_MODE[] = "camera-mode";
+const char CameraParameters::KEY_POWER_MODE[] = "power-mode";
+const char CameraParameters::KEY_POWER_MODE_SUPPORTED[] = "power-mode-supported";
+#endif
+const char CameraParameters::KEY_AE_BRACKET_HDR[] = "ae-bracket-hdr";
+
+/*only effective when KEY_AE_BRACKET_HDR set to ae_bracketing*/
+//const char CameraParameters::KEY_AE_BRACKET_SETTING_KEY[] = "ae-bracket-setting";
 
 const char CameraParameters::TRUE[] = "true";
 const char CameraParameters::FALSE[] = "false";
@@ -119,6 +174,15 @@ const char CameraParameters::EFFECT_POSTERIZE[] = "posterize";
 const char CameraParameters::EFFECT_WHITEBOARD[] = "whiteboard";
 const char CameraParameters::EFFECT_BLACKBOARD[] = "blackboard";
 const char CameraParameters::EFFECT_AQUA[] = "aqua";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::EFFECT_EMBOSS[] = "emboss";
+const char CameraParameters::EFFECT_SKETCH[] = "sketch";
+const char CameraParameters::EFFECT_NEON[] = "neon";
+
+// Values for auto exposure settings.
+const char CameraParameters::TOUCH_AF_AEC_OFF[] = "touch-off";
+const char CameraParameters::TOUCH_AF_AEC_ON[] = "touch-on";
+#endif
 
 // Values for antibanding settings.
 const char CameraParameters::ANTIBANDING_AUTO[] = "auto";
@@ -134,7 +198,8 @@ const char CameraParameters::FLASH_MODE_RED_EYE[] = "red-eye";
 const char CameraParameters::FLASH_MODE_TORCH[] = "torch";
 
 // Values for scene mode settings.
-const char CameraParameters::SCENE_MODE_AUTO[] = "auto";
+const char CameraParameters::SCENE_MODE_AUTO[] = "auto"; // corresponds to CAMERA_BESTSHOT_OFF in HAL
+const char CameraParameters::SCENE_MODE_ASD[] = "asd";   // corresponds to CAMERA_BESTSHOT_AUTO in HAL
 const char CameraParameters::SCENE_MODE_ACTION[] = "action";
 const char CameraParameters::SCENE_MODE_PORTRAIT[] = "portrait";
 const char CameraParameters::SCENE_MODE_LANDSCAPE[] = "landscape";
@@ -149,11 +214,28 @@ const char CameraParameters::SCENE_MODE_FIREWORKS[] = "fireworks";
 const char CameraParameters::SCENE_MODE_SPORTS[] = "sports";
 const char CameraParameters::SCENE_MODE_PARTY[] = "party";
 const char CameraParameters::SCENE_MODE_CANDLELIGHT[] = "candlelight";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::SCENE_MODE_BACKLIGHT[] = "backlight";
+const char CameraParameters::SCENE_MODE_FLOWERS[] = "flowers";
+#endif
 const char CameraParameters::SCENE_MODE_BARCODE[] = "barcode";
+
 const char CameraParameters::SCENE_MODE_HDR[] = "hdr";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::SCENE_MODE_AR[] = "AR";
+
+// Values for auto scene detection settings.
+const char CameraParameters::SCENE_DETECT_OFF[] = "off";
+const char CameraParameters::SCENE_DETECT_ON[] = "on";
+#endif
+
 
+// Formats for setPreviewFormat and setPictureFormat.
 const char CameraParameters::PIXEL_FORMAT_YUV422SP[] = "yuv422sp";
 const char CameraParameters::PIXEL_FORMAT_YUV420SP[] = "yuv420sp";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::PIXEL_FORMAT_YUV420SP_ADRENO[] = "yuv420sp-adreno";
+#endif
 const char CameraParameters::PIXEL_FORMAT_YUV422I[] = "yuv422i-yuyv";
 const char CameraParameters::PIXEL_FORMAT_YUV420P[]  = "yuv420p";
 const char CameraParameters::PIXEL_FORMAT_RGB565[] = "rgb565";
@@ -162,6 +244,12 @@ const char CameraParameters::PIXEL_FORMAT_JPEG[] = "jpeg";
 const char CameraParameters::PIXEL_FORMAT_BAYER_RGGB[] = "bayer-rggb";
 const char CameraParameters::PIXEL_FORMAT_ANDROID_OPAQUE[] = "android-opaque";
 
+#ifdef QCOM_HARDWARE
+const char CameraParameters::PIXEL_FORMAT_RAW[] = "raw";
+const char CameraParameters::PIXEL_FORMAT_YV12[] = "yuv420p";
+const char CameraParameters::PIXEL_FORMAT_NV12[] = "nv12";
+#endif
+
 // Values for focus mode settings.
 const char CameraParameters::FOCUS_MODE_AUTO[] = "auto";
 const char CameraParameters::FOCUS_MODE_INFINITY[] = "infinity";
@@ -172,6 +260,118 @@ const char CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO[] = "continuous-video";
 const char CameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE[] = "continuous-picture";
 const char CameraParameters::FOCUS_MODE_MANUAL_POSITION[] = "manual";
 
+#if defined(QCOM_HARDWARE)
+const char CameraParameters::FOCUS_MODE_NORMAL[] = "normal";
+
+
+const char CameraParameters::KEY_SKIN_TONE_ENHANCEMENT[] = "skinToneEnhancement";
+const char CameraParameters::KEY_SUPPORTED_SKIN_TONE_ENHANCEMENT_MODES[] = "skinToneEnhancement-values";
+
+// Values for ISO Settings
+const char CameraParameters::ISO_AUTO[] = "auto";
+const char CameraParameters::ISO_HJR[] = "ISO_HJR";
+const char CameraParameters::ISO_100[] = "ISO100";
+const char CameraParameters::ISO_200[] = "ISO200";
+const char CameraParameters::ISO_400[] = "ISO400";
+const char CameraParameters::ISO_800[] = "ISO800";
+const char CameraParameters::ISO_1600[] = "ISO1600";
+const char CameraParameters::ISO_3200[] = "ISO3200";
+const char CameraParameters::ISO_6400[] = "ISO6400";
+
+ //Values for Lens Shading
+const char CameraParameters::LENSSHADE_ENABLE[] = "enable";
+const char CameraParameters::LENSSHADE_DISABLE[] = "disable";
+
+// Values for auto exposure settings.
+const char CameraParameters::AUTO_EXPOSURE_FRAME_AVG[] = "frame-average";
+const char CameraParameters::AUTO_EXPOSURE_CENTER_WEIGHTED[] = "center-weighted";
+const char CameraParameters::AUTO_EXPOSURE_SPOT_METERING[] = "spot-metering";
+
+const char CameraParameters::KEY_GPS_LATITUDE_REF[] = "gps-latitude-ref";
+const char CameraParameters::KEY_GPS_LONGITUDE_REF[] = "gps-longitude-ref";
+const char CameraParameters::KEY_GPS_ALTITUDE_REF[] = "gps-altitude-ref";
+const char CameraParameters::KEY_GPS_STATUS[] = "gps-status";
+const char CameraParameters::KEY_EXIF_DATETIME[] = "exif-datetime";
+
+const char CameraParameters::KEY_HISTOGRAM[] = "histogram";
+const char CameraParameters::KEY_SUPPORTED_HISTOGRAM_MODES[] = "histogram-values";
+//Values for Histogram Shading
+const char CameraParameters::HISTOGRAM_ENABLE[] = "enable";
+const char CameraParameters::HISTOGRAM_DISABLE[] = "disable";
+
+//Values for Skin Tone Enhancement Modes
+const char CameraParameters::SKIN_TONE_ENHANCEMENT_ENABLE[] = "enable";
+const char CameraParameters::SKIN_TONE_ENHANCEMENT_DISABLE[] = "disable";
+
+const char CameraParameters::KEY_SHARPNESS[] = "sharpness";
+const char CameraParameters::KEY_MAX_SHARPNESS[] = "max-sharpness";
+const char CameraParameters::KEY_CONTRAST[] = "contrast";
+const char CameraParameters::KEY_MAX_CONTRAST[] = "max-contrast";
+const char CameraParameters::KEY_SATURATION[] = "saturation";
+const char CameraParameters::KEY_MAX_SATURATION[] = "max-saturation";
+
+//Values for DENOISE
+const char CameraParameters::DENOISE_OFF[] = "denoise-off";
+const char CameraParameters::DENOISE_ON[] = "denoise-on";
+// Values for selectable zone af Settings
+const char CameraParameters::SELECTABLE_ZONE_AF_AUTO[] = "auto";
+const char CameraParameters::SELECTABLE_ZONE_AF_SPOT_METERING[] = "spot-metering";
+const char CameraParameters::SELECTABLE_ZONE_AF_CENTER_WEIGHTED[] = "center-weighted";
+const char CameraParameters::SELECTABLE_ZONE_AF_FRAME_AVERAGE[] = "frame-average";
+
+// Values for Face Detection settings.
+const char CameraParameters::FACE_DETECTION_OFF[] = "off";
+const char CameraParameters::FACE_DETECTION_ON[] = "on";
+
+// Values for MCE settings.
+const char CameraParameters::MCE_ENABLE[] = "enable";
+const char CameraParameters::MCE_DISABLE[] = "disable";
+
+// Values for HFR settings.
+const char CameraParameters::VIDEO_HFR_OFF[] = "off";
+const char CameraParameters::VIDEO_HFR_2X[] = "60";
+const char CameraParameters::VIDEO_HFR_3X[] = "90";
+const char CameraParameters::VIDEO_HFR_4X[] = "120";
+
+// Values for Redeye Reduction settings.
+const char CameraParameters::REDEYE_REDUCTION_ENABLE[] = "enable";
+const char CameraParameters::REDEYE_REDUCTION_DISABLE[] = "disable";
+// Values for HDR settings.
+const char CameraParameters::HDR_ENABLE[] = "enable";
+const char CameraParameters::HDR_DISABLE[] = "disable";
+
+// Values for ZSL settings.
+const char CameraParameters::ZSL_OFF[] = "off";
+const char CameraParameters::ZSL_ON[] = "on";
+
+// Values for HDR Bracketing settings.
+const char CameraParameters::AE_BRACKET_HDR_OFF[] = "Off";
+const char CameraParameters::AE_BRACKET_HDR[] = "HDR";
+const char CameraParameters::AE_BRACKET[] = "AE-Bracket";
+
+const char CameraParameters::LOW_POWER[] = "Low_Power";
+const char CameraParameters::NORMAL_POWER[] = "Normal_Power";
+
+static const char* portrait = "portrait";
+static const char* landscape = "landscape";
+
+int CameraParameters::getOrientation() const
+{
+    const char* orientation = get("orientation");
+    if (orientation && !strcmp(orientation, portrait))
+        return CAMERA_ORIENTATION_PORTRAIT;
+    return CAMERA_ORIENTATION_LANDSCAPE;
+}
+void CameraParameters::setOrientation(int orientation)
+{
+    if (orientation == CAMERA_ORIENTATION_PORTRAIT) {
+        set("orientation", portrait);
+    } else {
+         set("orientation", landscape);
+    }
+}
+#endif
+
 // Values for light fx settings
 const char CameraParameters::LIGHTFX_LOWLIGHT[] = "low-light";
 const char CameraParameters::LIGHTFX_HDR[] = "high-dynamic-range";
@@ -272,7 +472,7 @@ void CameraParameters::set(const char *key, const char *value)
 void CameraParameters::set(const char *key, int value)
 {
     char str[16];
-    sprintf(str, "%d", value);
+    snprintf(str, sizeof(str), "%d", value);
     set(key, str);
 }
 
@@ -337,6 +537,32 @@ static int parse_pair(const char *str, int *first, int *second, char delim,
     return 0;
 }
 
+// Parse string like "(1, 2, 3, 4, ..., N)"
+// num is pointer to an allocated array of size N
+static int parseNDimVector(const char *str, int *num, int N, char delim = ',')
+{
+    char *start, *end;
+    if(num == NULL) {
+        ALOGE("Invalid output array (num == NULL)");
+        return -1;
+    }
+    //check if string starts and ends with parantheses
+    if(str[0] != '(' || str[strlen(str)-1] != ')') {
+        ALOGE("Invalid format of string %s, valid format is (n1, n2, n3, n4 ...)", str);
+        return -1;
+    }
+    start = (char*) str;
+    start++;
+    for(int i=0; i<N; i++) {
+        *(num+i) = (int) strtol(start, &end, 10);
+        if(*end != delim && i < N-1) {
+            ALOGE("Cannot find delimeter '%c' in string \"%s\". end = %c", delim, str, *end);
+            return -1;
+        }
+        start = end+1;
+    }
+    return 0;
+}
 static void parseSizesList(const char *sizesStr, Vector<Size> &sizes)
 {
     if (sizesStr == 0) {
@@ -365,7 +591,7 @@ static void parseSizesList(const char *sizesStr, Vector<Size> &sizes)
 void CameraParameters::setPreviewSize(int width, int height)
 {
     char str[32];
-    sprintf(str, "%dx%d", width, height);
+    snprintf(str, sizeof(str), "%dx%d", width, height);
     set(KEY_PREVIEW_SIZE, str);
 }
 
@@ -392,6 +618,21 @@ void CameraParameters::getSupportedPreviewSizes(Vector<Size> &sizes) const
     parseSizesList(previewSizesStr, sizes);
 }
 
+#ifdef QCOM_HARDWARE
+void CameraParameters::getSupportedHfrSizes(Vector<Size> &sizes) const
+{
+    const char *hfrSizesStr = get(KEY_SUPPORTED_HFR_SIZES);
+    parseSizesList(hfrSizesStr, sizes);
+}
+
+void CameraParameters::setPreviewFpsRange(int minFPS, int maxFPS)
+{
+    char str[32];
+    snprintf(str, sizeof(str), "%d,%d",minFPS,maxFPS);
+    set(KEY_PREVIEW_FPS_RANGE,str);
+}
+#endif
+
 void CameraParameters::setVideoSize(int width, int height)
 {
     char str[32];
@@ -431,6 +672,18 @@ void CameraParameters::getPreviewFpsRange(int *min_fps, int *max_fps) const
     parse_pair(p, min_fps, max_fps, ',');
 }
 
+#ifdef QCOM_HARDWARE
+void CameraParameters::setPreviewFrameRateMode(const char *mode)
+{
+    set(KEY_PREVIEW_FRAME_RATE_MODE, mode);
+}
+
+const char *CameraParameters::getPreviewFrameRateMode() const
+{
+    return get(KEY_PREVIEW_FRAME_RATE_MODE);
+}
+#endif
+
 void CameraParameters::setPreviewFormat(const char *format)
 {
     set(KEY_PREVIEW_FORMAT, format);
@@ -484,6 +737,71 @@ void CameraParameters::dump() const
     }
 }
 
+#ifdef QCOM_HARDWARE
+void CameraParameters::setTouchIndexAec(int x, int y)
+{
+    char str[32];
+    snprintf(str, sizeof(str), "%dx%d", x, y);
+    set(KEY_TOUCH_INDEX_AEC, str);
+}
+
+void CameraParameters::getTouchIndexAec(int *x, int *y) const
+{
+    *x = -1;
+    *y = -1;
+
+    // Get the current string, if it doesn't exist, leave the -1x-1
+    const char *p = get(KEY_TOUCH_INDEX_AEC);
+    if (p == 0)
+        return;
+
+    int tempX, tempY;
+    if (parse_pair(p, &tempX, &tempY, 'x') == 0) {
+        *x = tempX;
+        *y = tempY;
+    }
+}
+
+void CameraParameters::setTouchIndexAf(int x, int y)
+{
+    char str[32];
+    snprintf(str, sizeof(str), "%dx%d", x, y);
+    set(KEY_TOUCH_INDEX_AF, str);
+}
+
+void CameraParameters::getMeteringAreaCenter(int *x, int *y) const
+{
+    //Default invalid values
+    *x = -2000;
+    *y = -2000;
+
+    const char *p = get(KEY_METERING_AREAS);
+    if(p != NULL) {
+        int arr[5] = {-2000, -2000, -2000, -2000, 0};
+        parseNDimVector(p, arr, 5); //p = "(x1, y1, x2, y2, weight)"
+        *x = (arr[0] + arr[2])/2; //center_x = (x1+x2)/2
+        *y = (arr[1] + arr[3])/2; //center_y = (y1+y2)/2
+    }
+}
+
+void CameraParameters::getTouchIndexAf(int *x, int *y) const
+{
+    *x = -1;
+    *y = -1;
+
+    // Get the current string, if it doesn't exist, leave the -1x-1
+    const char *p = get(KEY_TOUCH_INDEX_AF);
+    if (p == 0)
+        return;
+
+    int tempX, tempY;
+    if (parse_pair(p, &tempX, &tempY, 'x') == 0) {
+        *x = tempX;
+        *y = tempY;
+    }
+}
+#endif
+
 status_t CameraParameters::dump(int fd, const Vector<String16>& /*args*/) const
 {
     const size_t SIZE = 256;
diff --git a/frameworks/av/include/camera/CameraParameters.h b/frameworks/av/include/camera/CameraParameters.h
index 078f8a3..e506c50 100644
--- a/frameworks/av/include/camera/CameraParameters.h
+++ b/frameworks/av/include/camera/CameraParameters.h
@@ -19,7 +19,6 @@
 
 #include <utils/KeyedVector.h>
 #include <utils/String8.h>
-#include <camera/CameraParametersExtra.h>
 
 namespace android {
 
@@ -37,7 +36,21 @@ struct Size {
         height = h;
     }
 };
-
+#ifdef QCOM_HARDWARE
+struct FPSRange{
+    int minFPS;
+    int maxFPS;
+
+    FPSRange(){
+        minFPS=0;
+        maxFPS=0;
+    };
+    FPSRange(int min,int max){
+        minFPS=min;
+        maxFPS=max;
+   };
+};
+#endif
 class CameraParameters
 {
 public:
@@ -92,6 +105,10 @@ public:
     void setPreviewFrameRate(int fps);
     int getPreviewFrameRate() const;
     void getPreviewFpsRange(int *min_fps, int *max_fps) const;
+#ifdef QCOM_HARDWARE
+    void setPreviewFrameRateMode(const char *mode);
+    const char *getPreviewFrameRateMode() const;
+#endif
     void setPreviewFormat(const char *format);
     const char *getPreviewFormat() const;
     void setPictureSize(int width, int height);
@@ -99,6 +116,14 @@ public:
     void getSupportedPictureSizes(Vector<Size> &sizes) const;
     void setPictureFormat(const char *format);
     const char *getPictureFormat() const;
+#ifdef QCOM_HARDWARE
+    void setTouchIndexAec(int x, int y);
+    void getTouchIndexAec(int *x, int *y) const;
+    void setTouchIndexAf(int x, int y);
+    void getTouchIndexAf(int *x, int *y) const;
+#endif
+
+    void getMeteringAreaCenter(int * x, int *y) const;
 
     void dump() const;
     status_t dump(int fd, const Vector<String16>& args) const;
@@ -119,6 +144,11 @@ public:
     // Supported preview frame sizes in pixels.
     // Example value: "800x600,480x320". Read only.
     static const char KEY_SUPPORTED_PREVIEW_SIZES[];
+#ifdef QCOM_HARDWARE
+    // Supported PREVIEW/RECORDING SIZES IN HIGH FRAME RATE recording, sizes in pixels.
+    // Example value: "800x480,432x320". Read only.
+    static const char KEY_SUPPORTED_HFR_SIZES[];
+#endif
     // The current minimum and maximum preview fps. This controls the rate of
     // preview frames received (CAMERA_MSG_PREVIEW_FRAME). The minimum and
     // maximum fps must be one of the elements from
@@ -148,6 +178,14 @@ public:
     // Supported number of preview frames per second.
     // Example value: "24,15,10". Read.
     static const char KEY_SUPPORTED_PREVIEW_FRAME_RATES[];
+#ifdef QCOM_HARDWARE
+    // The mode of preview frame rate.
+    // Example value: "frame-rate-auto, frame-rate-fixed".
+    static const char KEY_PREVIEW_FRAME_RATE_MODE[];
+    static const char KEY_SUPPORTED_PREVIEW_FRAME_RATE_MODES[];
+    static const char KEY_PREVIEW_FRAME_RATE_AUTO_MODE[];
+    static const char KEY_PREVIEW_FRAME_RATE_FIXED_MODE[];
+#endif
     // The dimensions for captured pictures in pixels (width x height).
     // Example value: "1024x768". Read/write.
     static const char KEY_PICTURE_SIZE[];
@@ -210,6 +248,12 @@ public:
     // header.
     // Example value: "21.0" or "-5". Write only.
     static const char KEY_GPS_ALTITUDE[];
+
+#ifdef QCOM_HARDWARE
+    static const char KEY_SKIN_TONE_ENHANCEMENT[] ;
+    static const char KEY_SUPPORTED_SKIN_TONE_ENHANCEMENT_MODES[] ;
+#endif
+
     // GPS timestamp (UTC in seconds since January 1, 1970). This should be
     // stored in JPEG EXIF header.
     // Example value: "1251192757". Write only.
@@ -226,9 +270,22 @@ public:
     // Current color effect setting.
     // Example value: "none" or EFFECT_XXX constants. Read/write.
     static const char KEY_EFFECT[];
+    // current orientation value
+    static const char KEY_ORIENTATION[];
+    static const char KEY_WATERMARK[];
+    static const char KEY_MIRROR[];
     // Supported color effect settings.
     // Example value: "none,mono,sepia". Read only.
     static const char KEY_SUPPORTED_EFFECTS[];
+#ifdef QCOM_HARDWARE
+    //Touch Af/AEC settings.
+    static const char KEY_TOUCH_AF_AEC[];
+    static const char KEY_SUPPORTED_TOUCH_AF_AEC[];
+    //Touch Index for AEC.
+    static const char KEY_TOUCH_INDEX_AEC[];
+    //Touch Index for AF.
+    static const char KEY_TOUCH_INDEX_AF[];
+#endif
     // Current antibanding setting.
     // Example value: "auto" or ANTIBANDING_XXX constants. Read/write.
     static const char KEY_ANTIBANDING[];
@@ -241,6 +298,14 @@ public:
     // Supported scene mode settings.
     // Example value: "auto,night,fireworks". Read only.
     static const char KEY_SUPPORTED_SCENE_MODES[];
+#ifdef QCOM_HARDWARE
+    // Current auto scene detection mode.
+    // Example value: "off" or SCENE_DETECT_XXX constants. Read/write.
+    static const char KEY_SCENE_DETECT[];
+    // Supported auto scene detection settings.
+    // Example value: "off,backlight,snow/cloudy". Read only.
+    static const char KEY_SUPPORTED_SCENE_DETECT[];
+#endif
     // Current flash mode.
     // Example value: "auto" or FLASH_MODE_XXX constants. Read/write.
     static const char KEY_FLASH_MODE[];
@@ -512,6 +577,23 @@ public:
     // captured pictures.
     // Example value: "true" or "false". Read only.
     static const char KEY_VIDEO_SNAPSHOT_SUPPORTED[];
+    static const char KEY_FULL_VIDEO_SNAP_SUPPORTED[];
+
+#ifdef QCOM_HARDWARE
+    static const char KEY_ISO_MODE[];
+    static const char KEY_SUPPORTED_ISO_MODES[];
+    static const char KEY_LENSSHADE[] ;
+    static const char KEY_SUPPORTED_LENSSHADE_MODES[] ;
+
+    static const char KEY_AUTO_EXPOSURE[];
+    static const char KEY_SUPPORTED_AUTO_EXPOSURE[];
+
+    static const char KEY_GPS_LATITUDE_REF[];
+    static const char KEY_GPS_LONGITUDE_REF[];
+    static const char KEY_GPS_ALTITUDE_REF[];
+    static const char KEY_GPS_STATUS[];
+    static const char KEY_EXIF_DATETIME[];
+#endif
 
     // The state of the video stabilization. If set to true, both the
     // preview stream and the recorded video stream are stabilized by
@@ -527,6 +609,23 @@ public:
     // has no effect on still image capture.
     static const char KEY_VIDEO_STABILIZATION[];
 
+#ifdef QCOM_HARDWARE
+    static const char KEY_MEMORY_COLOR_ENHANCEMENT[];
+    static const char KEY_SUPPORTED_MEM_COLOR_ENHANCE_MODES[];
+
+    static const char KEY_POWER_MODE_SUPPORTED[];
+    static const char KEY_POWER_MODE[];
+
+    static const char KEY_ZSL[];
+    static const char KEY_SUPPORTED_ZSL_MODES[];
+
+    static const char KEY_CAMERA_MODE[];
+
+    static const char KEY_VIDEO_HIGH_FRAME_RATE[];
+    static const char KEY_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES[];
+    static const char KEY_HIGH_DYNAMIC_RANGE_IMAGING[];
+    static const char KEY_SUPPORTED_HDR_IMAGING_MODES[];
+#endif
     // Returns true if video stabilization is supported. That is, applications
     // can set KEY_VIDEO_STABILIZATION to true and have a stabilized preview
     // stream and record stabilized videos.
@@ -536,6 +635,8 @@ public:
     // Example values: "lowlight,hdr".
     static const char KEY_LIGHTFX[];
 
+    static const char KEY_AE_BRACKET_HDR[];
+
     // Value for KEY_ZOOM_SUPPORTED or KEY_SMOOTH_ZOOM_SUPPORTED.
     static const char TRUE[];
     static const char FALSE[];
@@ -543,6 +644,24 @@ public:
     // Value for KEY_FOCUS_DISTANCES.
     static const char FOCUS_DISTANCE_INFINITY[];
 
+#ifdef QCOM_HARDWARE
+    // DENOISE
+    static const char KEY_DENOISE[];
+    static const char KEY_SUPPORTED_DENOISE[];
+
+    //Selectable zone AF.
+    static const char KEY_SELECTABLE_ZONE_AF[];
+    static const char KEY_SUPPORTED_SELECTABLE_ZONE_AF[];
+
+    //Face Detection
+    static const char KEY_FACE_DETECTION[];
+    static const char KEY_SUPPORTED_FACE_DETECTION[];
+
+    //Redeye Reduction
+    static const char KEY_REDEYE_REDUCTION[];
+    static const char KEY_SUPPORTED_REDEYE_REDUCTION[];
+#endif
+
     // Values for white balance settings.
     static const char WHITE_BALANCE_AUTO[];
     static const char WHITE_BALANCE_INCANDESCENT[];
@@ -564,6 +683,15 @@ public:
     static const char EFFECT_WHITEBOARD[];
     static const char EFFECT_BLACKBOARD[];
     static const char EFFECT_AQUA[];
+#ifdef QCOM_HARDWARE
+    static const char EFFECT_EMBOSS[];
+    static const char EFFECT_SKETCH[];
+    static const char EFFECT_NEON[];
+
+    // Values for Touch AF/AEC
+    static const char TOUCH_AF_AEC_OFF[] ;
+    static const char TOUCH_AF_AEC_ON[] ;
+#endif
 
     // Values for antibanding settings.
     static const char ANTIBANDING_AUTO[];
@@ -588,6 +716,7 @@ public:
 
     // Values for scene mode settings.
     static const char SCENE_MODE_AUTO[];
+    static const char SCENE_MODE_ASD[];
     static const char SCENE_MODE_ACTION[];
     static const char SCENE_MODE_PORTRAIT[];
     static const char SCENE_MODE_LANDSCAPE[];
@@ -602,6 +731,11 @@ public:
     static const char SCENE_MODE_SPORTS[];
     static const char SCENE_MODE_PARTY[];
     static const char SCENE_MODE_CANDLELIGHT[];
+#ifdef QCOM_HARDWARE
+    static const char SCENE_MODE_BACKLIGHT[];
+    static const char SCENE_MODE_FLOWERS[];
+    static const char SCENE_MODE_AR[];
+#endif
     // Applications are looking for a barcode. Camera driver will be optimized
     // for barcode reading.
     static const char SCENE_MODE_BARCODE[];
@@ -612,8 +746,15 @@ public:
 
     // Pixel color formats for KEY_PREVIEW_FORMAT, KEY_PICTURE_FORMAT,
     // and KEY_VIDEO_FRAME_FORMAT
+#ifdef QCOM_HARDWARE
+    static const char SCENE_DETECT_OFF[];
+    static const char SCENE_DETECT_ON[];
+#endif
     static const char PIXEL_FORMAT_YUV422SP[];
     static const char PIXEL_FORMAT_YUV420SP[]; // NV21
+#ifdef QCOM_HARDWARE
+    static const char PIXEL_FORMAT_YUV420SP_ADRENO[]; // ADRENO
+#endif
     static const char PIXEL_FORMAT_YUV422I[]; // YUY2
     static const char PIXEL_FORMAT_YUV420P[]; // YV12
     static const char PIXEL_FORMAT_RGB565[];
@@ -622,9 +763,16 @@ public:
     // Raw bayer format used for images, which is 10 bit precision samples
     // stored in 16 bit words. The filter pattern is RGGB.
     static const char PIXEL_FORMAT_BAYER_RGGB[];
+
     // Pixel format is not known to the framework
     static const char PIXEL_FORMAT_ANDROID_OPAQUE[];
 
+#ifdef QCOM_HARDWARE
+    static const char PIXEL_FORMAT_RAW[];
+    static const char PIXEL_FORMAT_YV12[]; // NV21
+    static const char PIXEL_FORMAT_NV12[]; //NV12
+#endif
+
     // Values for focus mode settings.
     // Auto-focus mode. Applications should call
     // CameraHardwareInterface.autoFocus to start the focus in this mode.
@@ -695,6 +843,107 @@ CAMERA_PARAMETERS_EXTRA_H
      */
     static int previewFormatToEnum(const char* format);
 
+#ifdef QCOM_HARDWARE
+    // Normal focus mode. Applications should call
+    // CameraHardwareInterface.autoFocus to start the focus in this mode.
+    static const char FOCUS_MODE_NORMAL[];
+    static const char ISO_AUTO[];
+    static const char ISO_HJR[] ;
+    static const char ISO_100[];
+    static const char ISO_200[] ;
+    static const char ISO_400[];
+    static const char ISO_800[];
+    static const char ISO_1600[];
+    static const char ISO_3200[];
+    static const char ISO_6400[];
+    // Values for Lens Shading
+    static const char LENSSHADE_ENABLE[] ;
+    static const char LENSSHADE_DISABLE[] ;
+
+    // Values for auto exposure settings.
+    static const char AUTO_EXPOSURE_FRAME_AVG[];
+    static const char AUTO_EXPOSURE_CENTER_WEIGHTED[];
+    static const char AUTO_EXPOSURE_SPOT_METERING[];
+
+    static const char KEY_SHARPNESS[];
+    static const char KEY_MAX_SHARPNESS[];
+    static const char KEY_CONTRAST[];
+    static const char KEY_MAX_CONTRAST[];
+    static const char KEY_SATURATION[];
+    static const char KEY_MAX_SATURATION[];
+
+    static const char KEY_HISTOGRAM[] ;
+    static const char KEY_SUPPORTED_HISTOGRAM_MODES[] ;
+    // Values for HISTOGRAM
+    static const char HISTOGRAM_ENABLE[] ;
+    static const char HISTOGRAM_DISABLE[] ;
+
+    // Values for SKIN TONE ENHANCEMENT
+    static const char SKIN_TONE_ENHANCEMENT_ENABLE[] ;
+    static const char SKIN_TONE_ENHANCEMENT_DISABLE[] ;
+
+    // Values for Denoise
+    static const char DENOISE_OFF[] ;
+    static const char DENOISE_ON[] ;
+
+    // Values for auto exposure settings.
+    static const char SELECTABLE_ZONE_AF_AUTO[];
+    static const char SELECTABLE_ZONE_AF_SPOT_METERING[];
+    static const char SELECTABLE_ZONE_AF_CENTER_WEIGHTED[];
+    static const char SELECTABLE_ZONE_AF_FRAME_AVERAGE[];
+
+    // Values for Face Detection settings.
+    static const char FACE_DETECTION_OFF[];
+    static const char FACE_DETECTION_ON[];
+
+    // Values for MCE settings.
+    static const char MCE_ENABLE[];
+    static const char MCE_DISABLE[];
+
+    // Values for ZSL settings.
+    static const char ZSL_OFF[];
+    static const char ZSL_ON[];
+
+    // Values for HDR Bracketing settings.
+    static const char AE_BRACKET_HDR_OFF[];
+    static const char AE_BRACKET_HDR[];
+    static const char AE_BRACKET[];
+
+    //POWER MODE
+    static const char LOW_POWER[];
+    static const char NORMAL_POWER[];
+
+    // Values for HFR settings.
+    static const char VIDEO_HFR_OFF[];
+    static const char VIDEO_HFR_2X[];
+    static const char VIDEO_HFR_3X[];
+    static const char VIDEO_HFR_4X[];
+
+    // Values for Redeye Reduction settings.
+    static const char REDEYE_REDUCTION_ENABLE[];
+    static const char REDEYE_REDUCTION_DISABLE[];
+    // Values for HDR settings.
+    static const char HDR_ENABLE[];
+    static const char HDR_DISABLE[];
+
+   // Values for Redeye Reduction settings.
+   // static const char REDEYE_REDUCTION_ENABLE[];
+   // static const char REDEYE_REDUCTION_DISABLE[];
+   // Values for HDR settings.
+   //    static const char HDR_ENABLE[];
+   //    static const char HDR_DISABLE[];
+
+    enum {
+        CAMERA_ORIENTATION_UNKNOWN = 0,
+        CAMERA_ORIENTATION_PORTRAIT = 1,
+        CAMERA_ORIENTATION_LANDSCAPE = 2,
+    };
+    int getOrientation() const;
+    void setOrientation(int orientation);
+    void setPreviewFpsRange(int minFPS,int maxFPS);
+    void getSupportedHfrSizes(Vector<Size> &sizes) const;
+#endif
+
 private:
     DefaultKeyedVector<String8,String8>    mMap;
 };
diff --git a/frameworks/av/services/camera/libcameraservice/CameraService.cpp b/frameworks/av/services/camera/libcameraservice/CameraService.cpp
index f18245f..e578cff 100644
--- a/frameworks/av/services/camera/libcameraservice/CameraService.cpp
+++ b/frameworks/av/services/camera/libcameraservice/CameraService.cpp
@@ -1222,7 +1222,13 @@ sp<CameraService::BasicClient> CameraService::findClientUnsafe(
         // Client::~Client() -> disconnect() -> removeClientByRemote().
         client = mClient[i].promote();
 
-        if ((client != NULL) && (cameraClient == client->getRemote())) {
+        // Clean up stale client entry
+        if (client == NULL) {
+            mClient[i].clear();
+            continue;
+        }
+
+        if (cameraClient == client->getRemote()) {
             // Found our camera
             outIndex = i;
             return client;
diff --git a/frameworks/av/services/camera/libcameraservice/CameraService.h b/frameworks/av/services/camera/libcameraservice/CameraService.h
index 817622b..1167483 100644
--- a/frameworks/av/services/camera/libcameraservice/CameraService.h
+++ b/frameworks/av/services/camera/libcameraservice/CameraService.h
@@ -23,7 +23,7 @@
 #include <binder/BinderService.h>
 #include <binder/IAppOpsCallback.h>
 #include <camera/ICameraService.h>
-#include "hardware/camera.h"
+#include <hardware/camera.h>
 
 #include <camera/ICamera.h>
 #include <camera/ICameraClient.h>
diff --git a/frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp b/frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp
index 248f5f5..9c4d7ff 100644
--- a/frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -709,9 +709,6 @@ void CameraClient::disableMsgType(int32_t msgType) {
 
 #define CHECK_MESSAGE_INTERVAL 10 // 10ms
 bool CameraClient::lockIfMessageWanted(int32_t msgType) {
-#ifdef MTK_HARDWARE
-    return true;
-#endif
     int sleepCount = 0;
     while (mMsgEnabled & msgType) {
         if ((msgType == CAMERA_MSG_PREVIEW_FRAME) &&
@@ -763,18 +760,6 @@ void CameraClient::notifyCallback(int32_t msgType, int32_t ext1,
         int32_t ext2, void* user) {
     LOG2("notifyCallback(%d)", msgType);
 
-#ifdef MTK_HARDWARE
-    if (msgType == 0x40000000) { //MTK_CAMERA_MSG_EXT_NOTIFY
-        if (ext1 == 0x11) { //MTK_CAMERA_MSG_EXT_NOTIFY_SHUTTER
-            msgType = CAMERA_MSG_SHUTTER;
-        }
-        if (ext1 == 0x10) { //MTK_CAMERA_MSG_EXT_CAPTURE_DONE
-            return;
-        }
-        LOG2("MtknotifyCallback(0x%x, 0x%x)", ext1, ext2);
-    }
-#endif
-
     Mutex* lock = getClientLockFromCookie(user);
     if (lock == NULL) return;
     Mutex::Autolock alock(*lock);
@@ -815,34 +800,6 @@ void CameraClient::dataCallback(int32_t msgType,
         return;
     }
 
-#ifdef MTK_HARDWARE
-    if (msgType == 0x80000000) { //MTK_CAMERA_MSG_EXT_DATA
-        struct DataHeader {
-            uint32_t        extMsgType;
-        } dataHeader;
-        sp<IMemoryHeap> heap = 0;
-        ssize_t         offset = 0;
-        size_t          size = 0;
-
-        if (dataPtr.get()) {
-
-            heap = dataPtr->getMemory(&offset, &size);
-            if  ( NULL != heap.get() && NULL != heap->base() )
-                ::memcpy(&dataHeader, ((uint8_t*)heap->base()) + offset, sizeof(DataHeader));
-
-            if (dataHeader.extMsgType == 0x10) { //MTK_CAMERA_MSG_EXT_DATA_COMPRESSED_IMAGE
-                msgType = CAMERA_MSG_COMPRESSED_IMAGE;
-                sp<MemoryBase> image = new MemoryBase(heap,
-                        (offset + sizeof(DataHeader) + sizeof(uint_t) * 1),
-                        (size - sizeof(DataHeader) - sizeof(uint_t) * 1));
-                client->handleCompressedPicture(image);
-                return;
-            }
-        }
-        LOG2("MtkDataCallback(0x%x)", dataHeader.extMsgType);
-    }
-#endif
-
     switch (msgType & ~CAMERA_MSG_PREVIEW_METADATA) {
         case CAMERA_MSG_PREVIEW_FRAME:
             client->handlePreviewData(msgType, dataPtr, metadata);
diff --git a/frameworks/av/services/camera/libcameraservice/device1/CameraHardwareInterface.h b/frameworks/av/services/camera/libcameraservice/device1/CameraHardwareInterface.h
index e5b3648..7cc18ad 100644
--- a/frameworks/av/services/camera/libcameraservice/device1/CameraHardwareInterface.h
+++ b/frameworks/av/services/camera/libcameraservice/device1/CameraHardwareInterface.h
@@ -25,12 +25,7 @@
 #include <camera/Camera.h>
 #include <camera/CameraParameters.h>
 #include <system/window.h>
-#include "hardware/camera.h"
-#ifdef USE_MEMORY_HEAP_ION
-#include <binder/MemoryHeapIon.h>
-#endif
-
-#include "CameraService.h"
+#include <hardware/camera.h>
 
 namespace android {
 
@@ -474,13 +469,17 @@ private:
         ALOGV("%s", __FUNCTION__);
         CameraHardwareInterface *__this =
                 static_cast<CameraHardwareInterface *>(user);
-        sp<CameraHeapMemory> mem(static_cast<CameraHeapMemory *>(data->handle));
-        if (index >= mem->mNumBufs) {
+        if (data != NULL) {
+          sp<CameraHeapMemory> mem(static_cast<CameraHeapMemory *>(data->handle));
+          if (index >= mem->mNumBufs) {
             ALOGE("%s: invalid buffer index %d, max allowed is %d", __FUNCTION__,
                  index, mem->mNumBufs);
             return;
+          }
+          __this->mDataCb(msg_type, mem->mBuffers[index], metadata, __this->mCbUser);
+        } else {
+          __this->mDataCb(msg_type, NULL, metadata, __this->mCbUser);
         }
-        __this->mDataCb(msg_type, mem->mBuffers[index], metadata, __this->mCbUser);
     }
 
     static void __data_cb_timestamp(nsecs_t timestamp, int32_t msg_type,
@@ -512,11 +511,7 @@ private:
                          mBufSize(buf_size),
                          mNumBufs(num_buffers)
         {
-#ifdef USE_MEMORY_HEAP_ION
-            mHeap = new MemoryHeapIon(fd, buf_size * num_buffers);
-#else
             mHeap = new MemoryHeapBase(fd, buf_size * num_buffers);
-#endif
             commonInitialization();
         }
 
@@ -524,11 +519,7 @@ private:
                          mBufSize(buf_size),
                          mNumBufs(num_buffers)
         {
-#ifdef USE_MEMORY_HEAP_ION
-            mHeap = new MemoryHeapIon(buf_size * num_buffers);
-#else
             mHeap = new MemoryHeapBase(buf_size * num_buffers);
-#endif
             commonInitialization();
         }
 
@@ -560,24 +551,14 @@ private:
         camera_memory_t handle;
     };
 
-#ifdef USE_MEMORY_HEAP_ION
-    static camera_memory_t* __get_memory(int fd, size_t buf_size, uint_t num_bufs,
-                                         void *ion_fd)
-    {
-#else
     static camera_memory_t* __get_memory(int fd, size_t buf_size, uint_t num_bufs,
                                          void *user __attribute__((unused)))
     {
-#endif
         CameraHeapMemory *mem;
         if (fd < 0)
             mem = new CameraHeapMemory(buf_size, num_bufs);
         else
             mem = new CameraHeapMemory(fd, buf_size, num_bufs);
-#ifdef USE_MEMORY_HEAP_ION
-        if (ion_fd)
-            *((int *) ion_fd) = mem->mHeap->getHeapID();
-#endif
         mem->incStrong(mem);
         return &mem->handle;
     }

project frameworks/base/
diff --git a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
index ca82b83..9a9b47f 100644
--- a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
+++ b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
@@ -27,7 +27,7 @@
     <string name="airplane_mode_toggleable_radios" translatable="false">bluetooth,wifi,nfc</string>
     <bool name="def_auto_time">true</bool>
     <bool name="def_auto_time_zone">true</bool>
-    <bool name="def_accelerometer_rotation">true</bool>
+    <bool name="def_accelerometer_rotation">false</bool>
     <!-- Bitmask of allowed display rotation angles:
            ROTATION_0_MODE: 1
            ROTATION_90_MODE: 2
@@ -44,14 +44,14 @@
 
     <bool name="def_bluetooth_on">false</bool>
     <bool name="def_wifi_display_on">false</bool>
-    <bool name="def_install_non_market_apps">false</bool>
-    <bool name="def_package_verifier_enable">true</bool>
+    <bool name="def_install_non_market_apps">true</bool>
+    <bool name="def_package_verifier_enable">false</bool>
     <!-- Comma-separated list of location providers.
          Network location is off by default because it requires
          user opt-in via Setup Wizard or Settings.
     -->
-    <string name="def_location_providers_allowed" translatable="false">gps</string>
-    <bool name="assisted_gps_enabled">true</bool>
+    <string name="def_location_providers_allowed" translatable="false"></string>
+    <bool name="assisted_gps_enabled">false</bool>
     <string name="assisted_gps_configurable_list" translatable="false"></string>
     <bool name="def_netstats_enabled">true</bool>
     <bool name="def_usb_mass_storage_enabled">true</bool>
@@ -180,10 +180,10 @@
     <!-- Default for DTMF tones enabled -->
     <bool name="def_dtmf_tones_enabled">true</bool>
     <!-- Default for UI touch sounds enabled -->
-    <bool name="def_sound_effects_enabled">true</bool>
+    <bool name="def_sound_effects_enabled">false</bool>
 
     <!-- Development settings -->
-    <bool name="def_stay_on_while_plugged_in">false</bool>
+    <bool name="def_stay_on_while_plugged_in">true</bool>
 
     <!-- Number of retries for connecting to DHCP.
          Value here is the same as WifiStateMachine.DEFAULT_MAX_DHCP_RETRIES -->
@@ -232,6 +232,9 @@
 
     <!-- Default for Settings.System.DOUBLE_TAP_SLEEP_GESTURE -->
     <integer name="def_double_tap_sleep_gesture">1</integer>
+    
+    <!-- Default for Settings.System.DOUBLE_TAP_WAKE_GESTURE -->
+    <integer name="def_double_tap_wake_gesture">1</integer>
 
     <!-- Default for Settings.Global.GUEST_USER_ENABLED -->
     <bool name="def_guest_user_enabled">true</bool>
diff --git a/frameworks/base/packages/SystemUI/res/values-zh-rCN/cm_strings.xml b/frameworks/base/packages/SystemUI/res/values-zh-rCN/cm_strings.xml
index 5de1fbc..225d47d 100644
--- a/frameworks/base/packages/SystemUI/res/values-zh-rCN/cm_strings.xml
+++ b/frameworks/base/packages/SystemUI/res/values-zh-rCN/cm_strings.xml
@@ -70,6 +70,7 @@
   <string name="accessibility_quick_settings_lte_on">LTE 开启。</string>
   <string name="accessibility_quick_settings_lte_changed_off">LTE 已关闭。</string>
   <string name="accessibility_quick_settings_lte_changed_on">LTE 已开启。</string>
+  <string name="quick_settings_visualizer_label" translatable="false">杜比音效</string>
   <string name="accessibility_quick_settings_nfc_off">NFC 关闭。</string>
   <string name="accessibility_quick_settings_nfc_on">NFC 开启。</string>
   <string name="accessibility_quick_settings_nfc_changed_off">NFC 已关闭。</string>
diff --git a/frameworks/base/packages/SystemUI/res/values-zh-rHK/cm_strings.xml b/frameworks/base/packages/SystemUI/res/values-zh-rHK/cm_strings.xml
index e65ab7f..28d5e03 100644
--- a/frameworks/base/packages/SystemUI/res/values-zh-rHK/cm_strings.xml
+++ b/frameworks/base/packages/SystemUI/res/values-zh-rHK/cm_strings.xml
@@ -65,6 +65,7 @@
   <string name="accessibility_quick_settings_lte_on">LTE 已開啟。</string>
   <string name="accessibility_quick_settings_lte_changed_off">LTE 已關閉。</string>
   <string name="accessibility_quick_settings_lte_changed_on">LTE 已開啟。</string>
+  <string name="quick_settings_visualizer_label" translatable="false">杜比音效</string>
   <string name="accessibility_quick_settings_nfc_off">NFC 已關閉。</string>
   <string name="accessibility_quick_settings_nfc_on">NFC 已開啟。</string>
   <string name="accessibility_quick_settings_nfc_changed_off">NFC 已關閉。</string>
diff --git a/frameworks/base/packages/SystemUI/res/values-zh-rTW/cm_strings.xml b/frameworks/base/packages/SystemUI/res/values-zh-rTW/cm_strings.xml
index a75d61e..f76893a 100644
--- a/frameworks/base/packages/SystemUI/res/values-zh-rTW/cm_strings.xml
+++ b/frameworks/base/packages/SystemUI/res/values-zh-rTW/cm_strings.xml
@@ -42,6 +42,7 @@
   <string name="accessibility_quick_settings_location_gps_only">位置回報：僅限裝置</string>
   <string name="accessibility_quick_settings_location_high_accuracy">位置回報：高精確度</string>
   <string name="accessibility_quick_settings_lte_off">LTE 已關閉。</string>
+  <string name="quick_settings_visualizer_label" translatable="false">杜比音效</string>
   <string name="accessibility_quick_settings_sync_off">同步關閉</string>
   <string name="accessibility_quick_settings_sync_on">同步開啟</string>
   <string name="accessibility_quick_settings_sync_changed_off">同步已關閉</string>
diff --git a/frameworks/base/packages/SystemUI/res/values/cm_strings.xml b/frameworks/base/packages/SystemUI/res/values/cm_strings.xml
index 9c01cf2..320e15f 100644
--- a/frameworks/base/packages/SystemUI/res/values/cm_strings.xml
+++ b/frameworks/base/packages/SystemUI/res/values/cm_strings.xml
@@ -261,7 +261,7 @@
     <string name="quick_settings_lockscreen_label_enforced">Lock screen enforced</string>
     <string name="quick_settings_network_adb_label">ADB over network</string>
     <string name="quick_settings_lte_label">LTE</string>
-    <string name="quick_settings_visualizer_label" translatable="false">AudioFX</string>
+    <string name="quick_settings_visualizer_label" translatable="false">Dolby</string>
     <string name="quick_settings_volume_panel_label">Volume panel</string>
     <string name="quick_settings_screen_timeout_detail_title">Screen timeout</string>
     <string name="quick_settings_usb_tether_label">USB tethering</string>
diff --git a/frameworks/base/services/core/java/com/android/server/NetworkManagementService.java b/frameworks/base/services/core/java/com/android/server/NetworkManagementService.java
index 1d041ed..7679e11 100644
--- a/frameworks/base/services/core/java/com/android/server/NetworkManagementService.java
+++ b/frameworks/base/services/core/java/com/android/server/NetworkManagementService.java
@@ -751,7 +751,7 @@ public class NetworkManagementService extends INetworkManagementService.Stub
                     boolean isActive = cooked[2].equals("active");
                     notifyInterfaceClassActivity(cooked[3] == null ? 0 : Integer.parseInt(cooked[3]),
                             isActive ? DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH
-                            : DataConnectionRealTimeInfo.DC_POWER_STATE_LOW, timestampNanos, false);
+                            : DataConnectionRealTimeInfo.DC_POWER_STATE_LOW, timestampNanos, true);
                     return true;
                     // break;
             case NetdResponseCode.InterfaceAddressChange:
@@ -1526,7 +1526,7 @@ public class NetworkManagementService extends INetworkManagementService.Stub
                 @Override public void run() {
                     notifyInterfaceClassActivity(type,
                             DataConnectionRealTimeInfo.DC_POWER_STATE_HIGH,
-                            SystemClock.elapsedRealtimeNanos(), false);
+                            SystemClock.elapsedRealtimeNanos(), true);
                 }
             });
         }
@@ -1555,7 +1555,7 @@ public class NetworkManagementService extends INetworkManagementService.Stub
                 @Override public void run() {
                     notifyInterfaceClassActivity(params.type,
                             DataConnectionRealTimeInfo.DC_POWER_STATE_LOW,
-                            SystemClock.elapsedRealtimeNanos(), false);
+                            SystemClock.elapsedRealtimeNanos(), true);
                 }
             });
         }
diff --git a/frameworks/base/telephony/java/android/telephony/TelephonyManager.java b/frameworks/base/telephony/java/android/telephony/TelephonyManager.java
index 1f64405..f01755a 100644
--- a/frameworks/base/telephony/java/android/telephony/TelephonyManager.java
+++ b/frameworks/base/telephony/java/android/telephony/TelephonyManager.java
@@ -3371,7 +3371,10 @@ public class TelephonyManager {
      */
     public int getTetherApnRequired() {
         try {
-            return getITelephony().getTetherApnRequired();
+            ITelephony telephony = getITelephony();
+            if (telephony != null) {
+                return telephony.getTetherApnRequired();
+            }
         } catch (RemoteException ex) {
             Rlog.e(TAG, "hasMatchedTetherApnSetting RemoteException", ex);
         } catch (NullPointerException ex) {

project frameworks/opt/telephony/
diff --git a/frameworks/opt/telephony/src/java/android/telephony/SmsMessage.java b/frameworks/opt/telephony/src/java/android/telephony/SmsMessage.java
index fce20f0..11a7371 100755
--- a/frameworks/opt/telephony/src/java/android/telephony/SmsMessage.java
+++ b/frameworks/opt/telephony/src/java/android/telephony/SmsMessage.java
@@ -30,7 +30,6 @@ import com.android.internal.telephony.SmsMessageBase.SubmitPduBase;
 import com.android.internal.telephony.Sms7BitEncodingTranslator;
 
 import java.lang.Math;
-import java.text.BreakIterator;	//[PM99] bug#1136 asing
 import java.util.ArrayList;
 import java.util.Arrays;
 
@@ -366,7 +365,6 @@ public class SmsMessage {
         // below cleanly if these MAX_* constants were defined more
         // flexibly...
 
-        Rlog.e(LOG_TAG, "fragmentText");
         int limit;
         if (ted.codeUnitSize == SmsConstants.ENCODING_7BIT) {
             int udhLength;
@@ -427,18 +425,7 @@ public class SmsMessage {
                             ted.languageTable, ted.languageShiftTable);
                 }
             } else {  // Assume unicode.
-//[PM99] bug#1136 asing s {      
-				
-                nextPos = Math.min(pos + limit / 2, textLen);
-				
-		  if (nextPos < textLen) {
-		      BreakIterator breakIterator = BreakIterator.getCharacterInstance();
-                    breakIterator.setText(newMsgBody.toString());
-                    if (!breakIterator.isBoundary(nextPos)) {
-                        nextPos = breakIterator.preceding(nextPos);
-                    }
-                }
-//[PM99] bug#1136 asing e {
+                nextPos = pos + Math.min(limit / 2, textLen - pos);
             }
             if ((nextPos <= pos) || (nextPos > textLen)) {
                 Rlog.e(LOG_TAG, "fragmentText failed (" + pos + " >= " + nextPos + " or " +
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMALTEPhone.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMALTEPhone.java
index d4074be..818ffbf 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMALTEPhone.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMALTEPhone.java
@@ -429,10 +429,8 @@ public class CDMALTEPhone extends CDMAPhone {
         IccRecords curIccRecords = null;
 
         if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_NV) {
-            operatorNumeric = SystemProperties.get(PROPERTY_CDMA_HOME_OPERATOR_NUMERIC);
-        }
-
-        if (TextUtils.isEmpty(operatorNumeric)) {
+            operatorNumeric = SystemProperties.get("ro.cdma.home.operator.numeric");
+        } else if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_RUIM_SIM) {
             curIccRecords = mSimRecords;
             if (curIccRecords != null) {
                 operatorNumeric = curIccRecords.getOperatorNumeric();
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMAPhone.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
index 2193e94..aca42a8 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CDMAPhone.java
@@ -663,7 +663,15 @@ public class CDMAPhone extends PhoneBase {
 
     @Override
     public String getSubscriberId() {
-        return mSST.getImsi();
+        if (mCdmaSubscriptionSource == CDMA_SUBSCRIPTION_NV) {
+            return mSST.getNvImsi();
+        } else {
+            IccRecords r = mIccRecords.get();
+            if (r != null) {
+                return r.getIMSI();
+            }
+        }
+        return null;
     }
 
     @Override
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
index 01d19bf..474cebc 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
@@ -430,17 +430,6 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
                     mIsMinInfoReady = true;
 
                     updateOtaspState();
-                    if (!mIsSubscriptionFromRuim && mIccRecords != null) {
-                        if (DBG) {
-                            log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
-                        }
-                        mIccRecords.setImsi(getImsi());
-                    } else {
-                        if (DBG) {
-                            log("GET_CDMA_SUBSCRIPTION either mIccRecords is null  or NV type device" +
-                                    " - not setting Imsi in mIccRecords");
-                        }
-                    }
                 } else {
                     if (DBG) {
                         log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription params num="
@@ -1900,10 +1889,9 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
     /**
      * Returns IMSI as MCC + MNC + MIN
      */
-    String getImsi() {
-        // TODO: When RUIM is enabled, IMSI will come from RUIM not build-time props.
+    public String getNvImsi() {
         String operatorNumeric = getSystemProperty(
-                TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC, "");
+                CDMAPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "");
 
         if (!TextUtils.isEmpty(operatorNumeric) && getCdmaMin() != null) {
             return (operatorNumeric + getCdmaMin());
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index 91ac2c0..c99d48e 100755
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -941,6 +941,7 @@ public final class DcTracker extends DcTrackerBase {
     }
 
     private boolean trySetupData(ApnContext apnContext) {
+        boolean retValue = false;
         if (DBG) {
             log("trySetupData for type:" + apnContext.getApnType() +
                     " due to " + apnContext.getReason() + " apnContext=" + apnContext);
@@ -983,10 +984,13 @@ public final class DcTracker extends DcTrackerBase {
                 ArrayList<ApnSetting> waitingApns = buildWaitingApns(apnContext.getApnType(),
                         radioTech);
                 if (waitingApns.isEmpty()) {
-                    notifyNoData(DcFailCause.MISSING_UNKNOWN_APN, apnContext);
                     notifyOffApnsOfAvailability(apnContext.getReason());
-                    if (DBG) log("trySetupData: X No APN found retValue=false");
-                    return false;
+                    retValue = setupData(apnContext, radioTech);
+                    if(!retValue) {
+                        notifyNoData(DcFailCause.MISSING_UNKNOWN_APN, apnContext);
+                    }
+                    notifyOffApnsOfAvailability(apnContext.getReason());
+                    return retValue;
                 } else {
                     apnContext.setWaitingApns(waitingApns);
                     if (DBG) {
@@ -1005,7 +1009,9 @@ public final class DcTracker extends DcTrackerBase {
                             + apnListToString(apnContext.getWaitingApns()));
                 }
             }
-            boolean retValue = setupData(apnContext, radioTech);
+
+            retValue = setupData(apnContext, radioTech);
+
             notifyOffApnsOfAvailability(apnContext.getReason());
 
             if (DBG) log("trySetupData: X retValue=" + retValue);
@@ -1410,8 +1416,38 @@ public final class DcTracker extends DcTrackerBase {
 
         apnSetting = apnContext.getNextWaitingApn();
         if (apnSetting == null) {
-            if (DBG) log("setupData: return for no apn found!");
-            return false;
+            if(PhoneConstants.PHONE_TYPE_CDMA==mPhone.getPhoneType()) {
+                String[] mDunApnTypes = { PhoneConstants.APN_TYPE_DUN };
+                final int mDefaultApnId = DctConstants.APN_DEFAULT_ID;
+                final String[] mDefaultApnTypes = {
+                    PhoneConstants.APN_TYPE_DEFAULT,
+                    PhoneConstants.APN_TYPE_MMS,
+                    PhoneConstants.APN_TYPE_SUPL,
+                    PhoneConstants.APN_TYPE_HIPRI,
+                    PhoneConstants.APN_TYPE_FOTA,
+                    PhoneConstants.APN_TYPE_IMS,
+                    PhoneConstants.APN_TYPE_CBS};
+
+
+                String[] types;
+                int apnId;
+                if (mRequestedApnType.equals(PhoneConstants.APN_TYPE_DUN)) {
+                    types = mDunApnTypes;
+                    apnId = DctConstants.APN_DUN_ID;
+                } else {
+                    types = mDefaultApnTypes;
+                    apnId = mDefaultApnId;
+                }
+                apnSetting = new ApnSetting(apnId, getOperatorNumeric(), null, null,
+                                null, null, null, null, null, null, null,
+                    RILConstants.SETUP_DATA_AUTH_PAP_CHAP, types,
+                    PROPERTY_CDMA_IPPROTOCOL, PROPERTY_CDMA_ROAMING_IPPROTOCOL, true, 0,
+                    0, false, 0, 0, 0, PhoneConstants.UNSET_MTU, "", "");
+                if (DBG) log("setupData: CDMA detected and apnSetting == null, use stubbed CDMA APN setting= " + apnSetting);
+            } else {
+                if (DBG) log("setupData: return for no apn found!");
+                return false;
+            }
         }
 
         int profileId = apnSetting.profileId;
@@ -2524,20 +2560,16 @@ public final class DcTracker extends DcTrackerBase {
      * @return operator numeric
      */
     private String getOperatorNumeric() {
-        String result = null;
-
+        String result;
         if (isNvSubscription()) {
             result = SystemProperties.get(CDMAPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC);
-        }
-
-        if (TextUtils.isEmpty(result)) {
+            log("getOperatorNumberic - returning from NV: " + result);
+        } else {
             IccRecords r = mIccRecords.get();
             result = (r != null) ? r.getOperatorNumeric() : "";
             log("getOperatorNumberic - returning from card: " + result);
-        } else {
-            log("getOperatorNumberic - returning from NV: " + result);
         }
-
+        if (result == null) result = "";
         return result;
     }
 
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
index faac818..64f1e8b 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/imsphone/ImsPhoneCallTracker.java
@@ -1673,6 +1673,7 @@ public final class ImsPhoneCallTracker extends CallTracker {
             // Make mIsSrvccCompleted flag to true after SRVCC complete.
             // After SRVCC complete sometimes SRV_STATUS_UPDATE come late.
             mIsSrvccCompleted = true;
+            mState = PhoneConstants.State.IDLE;
         }
     }
 
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccCardProxy.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
index c4c55c6..17bae02 100755
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
@@ -127,19 +127,6 @@ public class IccCardProxy extends Handler implements IccCard {
     private boolean mIsCardStatusAvailable = false;
     private PersoSubState mPersoSubState = PersoSubState.PERSOSUBSTATE_UNKNOWN;
 
-    // Sim State events may be broadcasted before the siminfo table update has been
-    // completed. Due to this such events may be broadcasted with dummy subId for a
-    // particular slotId. Therefore, setExternalState once the siminfo table has been updated.
-    // For example, if the UI receives the sim state broadcast with the state as pin locked
-    // with dummy subId, the pin lock screen will not be displayed.
-    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
-            @Override
-            public void onReceive(Context context, Intent intent) {
-                if (TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED.equals(intent.getAction())) {
-                    setExternalState(mExternalState, true);
-                }
-            }};
-
     public IccCardProxy(Context context, CommandsInterface ci, int phoneId) {
         if (DBG) log("ctor: ci=" + ci + " phoneId=" + phoneId);
         mContext = context;
@@ -151,10 +138,6 @@ public class IccCardProxy extends Handler implements IccCard {
         mUiccController.registerForIccChanged(this, EVENT_ICC_CHANGED, null);
         ci.registerForOn(this,EVENT_RADIO_ON, null);
         ci.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_UNAVAILABLE, null);
-        IntentFilter filter =
-                new IntentFilter(TelephonyIntents.ACTION_SUBINFO_RECORD_UPDATED);
-        mContext.registerReceiver(mReceiver, filter);
-
         resetProperties();
         setExternalState(State.NOT_READY, false);
     }
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccRecords.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccRecords.java
index 86bdca9..dd3e53c 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccRecords.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccRecords.java
@@ -338,16 +338,7 @@ public abstract class IccRecords extends Handler implements IccConstants {
      * @return null if SIM is not yet ready or unavailable
      */
     public String getIMSI() {
-        return null;
-    }
-
-    /**
-     * Imsi could be set by ServiceStateTrackers in case of cdma
-     * @param imsi
-     */
-    public void setImsi(String imsi) {
-        mImsi = imsi;
-        mImsiReadyRegistrants.notifyRegistrants();
+        return mImsi;
     }
 
     /**
diff --git a/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/RuimRecords.java b/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/RuimRecords.java
index 4d16293..87c0c5e 100644
--- a/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/RuimRecords.java
+++ b/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/RuimRecords.java
@@ -181,11 +181,6 @@ public final class RuimRecords extends IccRecords {
         mRecordsRequested = false;
     }
 
-    @Override
-    public String getIMSI() {
-        return mImsi;
-    }
-
     public String getMdnNumber() {
         return mMyMobileNumber;
     }

project hardware/qcom/audio-caf/msm8960/
diff --git a/hardware/qcom/audio-caf/msm8960/Android.mk b/hardware/qcom/audio-caf/msm8960/Android.mk
index 7845616..b707358 100644
--- a/hardware/qcom/audio-caf/msm8960/Android.mk
+++ b/hardware/qcom/audio-caf/msm8960/Android.mk
@@ -1,5 +1,3 @@
-ifeq ($(call my-dir),$(call project-path-for,qcom-audio))
-
 ifneq ($(filter msm8960 msm8226 msm8x26 msm8974 msm8x74,$(TARGET_BOARD_PLATFORM)),)
 
 MY_LOCAL_PATH := $(call my-dir)
@@ -11,5 +9,3 @@ include $(MY_LOCAL_PATH)/hal/Android.mk
 endif
 
 endif
-
-endif
diff --git a/hardware/qcom/audio-caf/msm8960/hal/Android.mk b/hardware/qcom/audio-caf/msm8960/hal/Android.mk
index 2056975..aa087c2 100644
--- a/hardware/qcom/audio-caf/msm8960/hal/Android.mk
+++ b/hardware/qcom/audio-caf/msm8960/hal/Android.mk
@@ -27,7 +27,7 @@ LOCAL_C_INCLUDES += \
 	$(call include-path-for, audio-effects)
 
 LOCAL_COPY_HEADERS_TO   := mm-audio
-LOCAL_COPY_HEADERS      := audio_defs.h
+LOCAL_COPY_HEADERS      := audio_extn/audio_defs.h
 
 LOCAL_MODULE := audio.primary.$(TARGET_BOARD_PLATFORM)
 
diff --git a/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/ALSADevice.cpp b/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/ALSADevice.cpp
index 9d1a136..9b251dd 100644
--- a/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/ALSADevice.cpp
+++ b/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/ALSADevice.cpp
@@ -85,7 +85,13 @@ namespace sys_close {
 namespace android_audio_legacy
 {
 
+#ifdef USE_ES310
+//XIAOMI_START
+ALSADevice::ALSADevice(AudioHardwareALSA* parent) {
+#else
 ALSADevice::ALSADevice() {
+#endif
+//XIAOMI_END
     mSSRComplete = false;
 #ifdef USES_FLUENCE_INCALL
     mDevSettingsFlag = TTY_OFF | DMIC_FLAG;
@@ -132,11 +138,12 @@ ALSADevice::ALSADevice() {
     mProxyParams.mProxyState = proxy_params::EProxyClosed;
     mProxyParams.mProxyPcmHandle = NULL;
 
-#ifdef USE_A2220
-    mA2220Fd = -1;
-    mA2220Mode = A2220_PATH_INCALL_RECEIVER_NSOFF;
+//XIAOMI_START
+#ifdef USE_ES310
+    mPrevDevice = 0;
+    mParent = parent;
 #endif
-
+//XIAOMI_END
 #ifdef SEPERATED_AUDIO_INPUT
     mInputSource = AUDIO_SOURCE_DEFAULT;
 #endif
@@ -551,9 +558,31 @@ void ALSADevice::switchDevice(alsa_handle_t *handle, uint32_t devices, uint32_t
     char *rxDevice, *txDevice, ident[70], *use_case = NULL;
     int err = 0, index, mods_size;
     int rx_dev_id, tx_dev_id;
-    ALOGV("%s: device %#x mode:%d", __FUNCTION__, devices, mode);
 
+#ifdef USE_ES310
+    ALOGV("%s: device:0x%x, mPrevDevice:0x%x", __FUNCTION__, devices, mPrevDevice);
+#else
+    ALOGV("%s: device %#x mode:%d", __FUNCTION__, devices, mode);
+#endif
     if ((mode == AUDIO_MODE_IN_CALL)  || (mode == AUDIO_MODE_IN_COMMUNICATION)) {
+//XIAOMI_START
+#ifdef USE_ES310
+        if (mPrevDevice != 0) {
+            ALOGV("devices & AudioSystem::DEVICE_OUT_ALL:0x%x", devices & AudioSystem::DEVICE_OUT_ALL);
+            if ((devices & AudioSystem::DEVICE_OUT_ALL) == 0) {
+                ALOGE("Should keep previous devices");
+                devices = devices | ((devices & AudioSystem::DEVICE_IN_ALL) | (mPrevDevice & AudioSystem::DEVICE_OUT_ALL));
+                ALOGE("device:%x, 0", devices);
+                if ((devices & AudioSystem::DEVICE_OUT_ALL) == 0) {
+                    ALOGE("set default RX path to earpiece");
+                    devices = devices | (AudioSystem::DEVICE_OUT_EARPIECE);
+                }
+                ALOGE("device:%x, 0-1", devices);
+                goto ROUTE;
+            }
+        }
+#endif
+//XIAOMI_END
         if ((devices & AudioSystem::DEVICE_OUT_WIRED_HEADSET) ||
             (devices & AudioSystem::DEVICE_IN_WIRED_HEADSET)) {
             devices = devices | (AudioSystem::DEVICE_OUT_WIRED_HEADSET |
@@ -625,6 +654,10 @@ void ALSADevice::switchDevice(alsa_handle_t *handle, uint32_t devices, uint32_t
             ALOGE("SwitchDevice:: Invalid A2DP Combination for mode %d", mode);
         }
     }
+#ifdef USE_ES310
+ROUTE:
+    mPrevDevice  = devices;
+#endif
 #ifdef QCOM_SSR_ENABLED
     if ((devices & AudioSystem::DEVICE_IN_BUILTIN_MIC) && ( 6 == handle->channels)) {
         if (!strncmp(handle->useCase, SND_USE_CASE_VERB_HIFI_REC, strlen(SND_USE_CASE_VERB_HIFI_REC))
@@ -657,6 +690,15 @@ void ALSADevice::switchDevice(alsa_handle_t *handle, uint32_t devices, uint32_t
              (mode == AUDIO_MODE_IN_COMMUNICATION)))
             inCallDevSwitch = true;
     }
+//XIAOMI_START
+#ifdef USE_ES310
+    ALOGV("rxDevice:%s, mCurRxUCMDevice:%s, mode:%d", rxDevice, mCurRxUCMDevice, mode);
+    if (((mode == AUDIO_MODE_IN_CALL) ||(mode == AUDIO_MODE_IN_COMMUNICATION)) &&
+        (strncmp(rxDevice, mCurRxUCMDevice, MAX_STR_LEN))) {
+        mParent->enableAudienceloopback(0);
+    }
+#endif
+//XIAOMI_END
 
 #ifdef QCOM_CSDCLIENT_ENABLED
     if (isPlatformFusion3() && (inCallDevSwitch == true)) {
@@ -701,6 +743,11 @@ void ALSADevice::switchDevice(alsa_handle_t *handle, uint32_t devices, uint32_t
                     }
                 }
             }
+//XIAOMI_START
+#ifdef USE_ES310
+            mParent->enableAudienceloopback(0);
+#endif
+//XIAOMI_END
             snd_use_case_set(handle->ucMgr, "_disdev", mCurRxUCMDevice);
             amplifier_enable_devices(current_rx_devices, false);
         }
@@ -844,7 +891,24 @@ void ALSADevice::switchDevice(alsa_handle_t *handle, uint32_t devices, uint32_t
         setFmVolume(mFmVolume);
     }
 #endif
-
+//XIAOMI_START
+#ifdef USE_ES310
+    unsigned int input_device = 0;
+    if (((devices & AUDIO_DEVICE_IN_ALL) == 0) &&
+        (mCurTxUCMDevice != NULL) &&
+        (mode == AudioSystem::MODE_NORMAL)) {
+        if (!strncmp("Line", mCurTxUCMDevice, MAX_STR_LEN)) {
+            ALOGE("Add Builtin Mic device");
+            input_device = AudioSystem::DEVICE_IN_BUILTIN_MIC;
+        }
+        if (!strncmp("HeadsetMic TX", mCurTxUCMDevice, MAX_STR_LEN)) {
+            ALOGE("Add wired headset device");
+            input_device = AudioSystem::DEVICE_IN_WIRED_HEADSET;
+        }
+    }
+    mParent->doRouting_Audience_Codec(mode, devices | input_device, true);
+#endif
+//XIAOMI_END
 #ifdef QCOM_CSDCLIENT_ENABLED
     if (isPlatformFusion3() && (inCallDevSwitch == true)) {
         if (((rx_dev_id == DEVICE_SPEAKER_MONO_RX_ACDB_ID ) || (rx_dev_id == DEVICE_SPEAKER_STEREO_RX_ACDB_ID ))
@@ -852,7 +916,11 @@ void ALSADevice::switchDevice(alsa_handle_t *handle, uint32_t devices, uint32_t
             tx_dev_id = DEVICE_SPEAKER_TX_ACDB_ID;
         }
         ALOGV("rx_dev_id=%d, tx_dev_id=%d\n", rx_dev_id, tx_dev_id);
-
+//XIAOMI_START
+#ifdef USE_ES310
+        mParent->enableAudienceloopback(1);
+#endif
+//XIAOMI_END
         if (csd_enable_device == NULL) {
             ALOGE("csd_client_enable_device is NULL");
         } else {
@@ -1697,7 +1765,11 @@ char *ALSADevice::getUCMDeviceFromAcdbId(int acdb_id)
 char* ALSADevice::getUCMDevice(uint32_t devices, int input, char *rxDevice)
 {
     char value[PROPERTY_VALUE_MAX];
-
+#ifdef USE_ES310
+    ALOGV("getUCMDevice devices=0x%x, input=0x%x", devices, input);
+    ALOGV("CallMode = %d, CallActiveState:%d", mCallMode, mParent->getCallState());
+    int bDuringIncall = mParent->getCallState();
+#endif
     if (!input) {
         ALOGV("getUCMDevice for output device: devices:%x is input device:%d",devices,input);
         if (!(mDevSettingsFlag & TTY_OFF) &&
@@ -1849,19 +1921,17 @@ char* ALSADevice::getUCMDevice(uint32_t devices, int input, char *rxDevice)
                     return strdup(SND_USE_CASE_DEV_ANC_HEADSET); /* ANC HEADSET RX */
                 }
             } else {
-#ifdef SEPERATED_VOIP
-                if (mCallMode == AUDIO_MODE_IN_COMMUNICATION) {
-                    return strdup(SND_USE_CASE_DEV_VOIP_HEADPHONE);
-                } else if (mCallMode == AUDIO_MODE_IN_CALL) {
-#else
-                if (mCallMode == AUDIO_MODE_IN_CALL ||
-                    mCallMode == AUDIO_MODE_IN_COMMUNICATION) {
+                if ((mCallMode == AUDIO_MODE_IN_CALL)
+#ifdef USE_ES310
+                 || (bDuringIncall == CALL_ACTIVE)
 #endif
+                 ) {
+                    ALOGV("Phone mode using SND_USE_CASE_DEV_VOC_HEADPHONE");
                     return strdup(SND_USE_CASE_DEV_VOC_HEADPHONE); /* Voice HEADSET RX */
-#ifdef SEPERATED_FM
-                } else if (mIsFmEnabled) {
-                    return strdup(SND_USE_CASE_DEV_FM_HEADSET);
-#endif
+                }
+                if (mCallMode == AUDIO_MODE_IN_COMMUNICATION) {
+                    ALOGV("Phone mode using SND_USE_CASE_DEV_VOIP_HEADPHONE");
+                    return strdup(SND_USE_CASE_DEV_VOC_HEADPHONE); /* VOIP HEADSET RX */
                 } else {
                     return strdup(SND_USE_CASE_DEV_HEADPHONES); /* HEADSET RX */
                 }
@@ -2055,6 +2125,11 @@ char* ALSADevice::getUCMDevice(uint32_t devices, int input, char *rxDevice)
                             strlen(SND_USE_CASE_DEV_ANC_HANDSET) + 1)) {
                         return strdup(SND_USE_CASE_DEV_AANC_LINE); /* AANC LINE TX */
                     } else {
+#ifdef USE_ES310
+					if (mCallMode == AUDIO_MODE_IN_CALL) {
+						return strdup(SND_USE_CASE_DEV_VOC_LINE); /* VOICE BUILTIN-MIC TX */
+					}
+#endif
                         return strdup(SND_USE_CASE_DEV_LINE); /* BUILTIN-MIC TX */
                     }
                 }
diff --git a/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/Android.mk b/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/Android.mk
index 3200477..699e110 100644
--- a/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/Android.mk
+++ b/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/Android.mk
@@ -101,12 +101,12 @@ ifeq ($(strip $(BOARD_USES_SEPERATED_FM)),true)
     common_cflags += -DSEPERATED_FM
 endif
 
-ifeq ($(BOARD_HAVE_AUDIENCE_A2220),true)
-    common_cflags += -DUSE_A2220
+ifeq ($(BOARD_HAVE_AUDIENCE_ES310),true)
+    common_cflags += -DUSE_ES310
 endif
 
-ifeq ($(BOARD_HAVE_SAMSUNG_AUDIO),true)
-    common_cflags += -DSAMSUNG_AUDIO
+ifeq ($(TARGET_PRODUCT),taurus)
+    common_cflags += -DTAURUS
 endif
 
 ifeq ($(BOARD_HAVE_NEW_QCOM_CSDCLIENT),true)
diff --git a/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioHardwareALSA.cpp b/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioHardwareALSA.cpp
index 42854b0..4afa5f9 100644
--- a/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioHardwareALSA.cpp
+++ b/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioHardwareALSA.cpp
@@ -187,6 +187,11 @@ int sendCodecCal(acdb_loader_get_calibration_t acdb_loader_get_calibration, int
 AudioHardwareALSA::AudioHardwareALSA() :
     mALSADevice(0),mVoipInStreamCount(0),mVoipOutStreamCount(0),mVoipMicMute(false),
     mVoipBitRate(0),mMicMute(0),mCallState(CALL_INACTIVE),mAcdbHandle(NULL),mCsdHandle(NULL)
+//XIAOMI_START
+#ifdef USE_ES310
+    ,mAudienceCodecInit(0)
+#endif
+//XIAOMI_END
 {
     FILE *fp;
     char soundCardInfo[200];
@@ -239,7 +244,11 @@ AudioHardwareALSA::AudioHardwareALSA() :
     acdb_deallocate = NULL;
 #endif
 
+#ifdef USE_ES310
+    mALSADevice = new ALSADevice(this);
+#else
     mALSADevice = new ALSADevice();
+#endif
     if (!mALSADevice) {
         mStatus = NO_INIT;
         return;
@@ -437,6 +446,17 @@ AudioHardwareALSA::AudioHardwareALSA() :
             mUcMgr->acdb_handle = static_cast<void*> (mAcdbHandle);
         }
     }
+//XIAOMI_START
+#ifdef USE_ES310
+    mLoopbackState = 0;
+    ALOGE("doAudienceCodec_Init+");
+    if (mAudienceCodecInit == 0) {
+        Mutex::Autolock lock(mAudioCodecLock);
+        doAudienceCodec_Init();
+    }
+    ALOGE("doAudienceCodec_Init-");
+#endif
+//XIAOMI_END
 
     //set default AudioParameters
     AudioParameter param;
@@ -506,6 +526,11 @@ void AudioHardwareALSA::initCodecCalib()
 
 AudioHardwareALSA::~AudioHardwareALSA()
 {
+//XIAOMI_START
+#ifdef USE_ES310
+    doAudienceCodec_DeInit();
+#endif
+//XIAOMI_END
     if (mUcMgr != NULL) {
         ALOGV("closing ucm instance: %u", (unsigned)mUcMgr);
         snd_use_case_mgr_close(mUcMgr);
@@ -604,6 +629,15 @@ status_t AudioHardwareALSA::setMasterVolume(float volume)
 status_t AudioHardwareALSA::setMode(int mode)
 {
     status_t status = NO_ERROR;
+//XIAOMI_START
+#ifdef USE_ES310
+    if ((mMode == AUDIO_MODE_RINGTONE) &&
+        (mode == AUDIO_MODE_NORMAL)) {
+        enableAudienceloopback(0);
+        doRouting_Audience_Codec( 0, 0, false);
+    }
+#endif
+//XIAOMI_END
 
     ALOGV("%s() mode=%d mMode=%d", __func__, mode, mMode);
 
@@ -611,7 +645,28 @@ status_t AudioHardwareALSA::setMode(int mode)
         status = AudioHardwareBase::setMode(mode);
     }
 
+#ifdef USE_ES310
+    if (mode == AUDIO_MODE_RINGTONE) {
+//XIAOMI_START
+        if (mAudienceCmd == CMD_AUDIENCE_READY)
+        {
+            mAudienceCmd = CMD_AUDIENCE_WAKEUP;
+            pthread_cond_signal(&mAudienceCV);
+        }
+//XIAOMI_END
+    }
+#endif
+
     if (mode == AUDIO_MODE_IN_CALL) {
+//XIAOMI_START
+#ifdef USE_ES310
+        if (mAudienceCmd == CMD_AUDIENCE_READY)
+        {
+            mAudienceCmd = CMD_AUDIENCE_WAKEUP;
+            pthread_cond_signal(&mAudienceCV);
+        }
+#endif
+//XIAOMI_END
         if (mCallState == CALL_INACTIVE) {
 #ifndef QCOM_MULTI_VOICE_SESSION_ENABLED
             ALOGV("%s() defaulting vsid and call state",__func__);
@@ -2188,6 +2243,800 @@ AudioHardwareALSA::closeInputStream(AudioStreamIn* in)
     delete in;
 }
 
+//XIAOMI_START
+#ifdef USE_ES310
+#define BUFSIZE_UART 1024
+#define VOICEPROC_MAX_FW_SIZE	(32 * 4096)
+
+static ES310_PathID dwOldPath = ES310_PATH_SUSPEND;
+static ES310_PathID dwNewPath = ES310_PATH_SUSPEND;
+static int AudiencePrevMode = AUDIO_MODE_NORMAL;
+static unsigned int dwOldPreset = -1;
+static unsigned int dwNewPreset = -1;
+
+//Call this API after enabling the Audience, Also call this API before disabling the Audience
+void AudioHardwareALSA::enableAudienceloopback(int enable)
+{
+    if (mAudienceCodecInit != 1) {
+        ALOGE("Audience Codec not initialized.\n");
+        return;
+    }
+
+    if (mLoopbackState == enable)
+        return;
+
+    ALOGV("enableAudienceloopback enable:%d", enable);
+    if(enable ==1 ) {
+        mALSADevice->setMixerControl("IIR1 INP1 MUX", "DEC2");
+    }
+    else {
+        mALSADevice->setMixerControl("RX1 Digital Volume",1,0);
+        mALSADevice->setMixerControl("RX2 Digital Volume",1,0);
+        mALSADevice->setMixerControl("RX3 Digital Volume",1,0);
+        mALSADevice->setMixerControl("RX4 Digital Volume",1,0);
+        mALSADevice->setMixerControl("IIR1 INP1 MUX", "ZERO");
+    }
+
+    mLoopbackState = enable;
+}
+
+static void setHigherBaudrate(int uart_fd, int baud)
+{
+	struct termios2 ti2;
+       struct termios ti;
+	/* Flush non-transmitted output data,
+	 * non-read input data or both
+	 */
+	tcflush(uart_fd, TCIFLUSH);
+
+	/* Set the UART flow control */
+
+	ti.c_cflag |= 1;
+
+	/* ti.c_cflag |= (CLOCAL | CREAD | CSTOPB); */
+	/*	ti.c_cflag &= ~(CRTSCTS | PARENB); */
+
+	/*
+	 * Enable the receiver and set local mode + 2 STOP bits
+	 */
+	ti.c_cflag |= (CLOCAL | CREAD | CSTOPB);
+	/* 8 data bits */
+	ti.c_cflag &= ~CSIZE;
+	ti.c_cflag |= CS8;
+	/* diable HW flow control and parity check */
+	ti.c_cflag &= ~(CRTSCTS | PARENB);
+
+	/* choose raw input */
+	ti.c_lflag &= ~(ICANON | ECHO);
+	/* choose raw output */
+	ti.c_oflag &= ~OPOST;
+	/* ignore break condition, CR and parity error */
+	ti.c_iflag |= (IGNBRK | IGNPAR);
+	ti.c_iflag &= ~(IXON | IXOFF | IXANY);
+	ti.c_cc[VMIN] = 0;
+	ti.c_cc[VTIME] = 10;
+
+	/*
+	 * Set the parameters associated with the UART
+	 * The change will occur immediately by using TCSANOW
+	 */
+	if (tcsetattr(uart_fd, TCSANOW, &ti) < 0) {
+		printf("Can't set port settings\n");
+		return;
+	}
+
+	tcflush(uart_fd, TCIFLUSH);
+
+	/* Set the actual baud rate */
+	ioctl(uart_fd, TCGETS2, &ti2);
+	ti2.c_cflag &= ~CBAUD;
+	ti2.c_cflag |= BOTHER;
+	ti2.c_ospeed = baud;
+	ti2.c_ispeed = baud;
+	ioctl(uart_fd, TCSETS2, &ti2);
+}
+
+int sendDownloadCmd(int uart_fd)
+{
+	unsigned char respBuffer = 0xcc, tmp;
+	int nretry = 10, rc;
+	int BytesWritten, readCnt;
+
+	tmp = 0x00;
+	BytesWritten = write(uart_fd, &tmp, 1);
+	if (BytesWritten == -1)
+		ALOGE("error writing synccmd to comm port: %s\n", strerror(errno));
+	else
+		ALOGE("Uart_write BytesWritten = %i\n", BytesWritten);
+
+	usleep(1000);
+	readCnt = read(uart_fd, &respBuffer, 1);
+	if (readCnt == -1)
+		ALOGE("error reading bootcmd from comm port: %s\n", strerror(errno));
+	else
+		ALOGE("readCnt = %d, respBuffer = %.2x\n", readCnt, respBuffer);
+	usleep(1000);
+
+	tmp = 0x01;
+	BytesWritten = write(uart_fd, &tmp, 1);
+	if (BytesWritten == -1)
+		ALOGE("error writing bootcmd to comm port: %s\n", strerror(errno));
+	else
+		ALOGE("Uart_write BytesWritten = %i\n", BytesWritten);
+
+	usleep(1000);
+	readCnt = read(uart_fd, &respBuffer, 1);
+	if (readCnt == -1)
+		ALOGE("error reading bootcmd from comm port: %s\n", strerror(errno));
+	else
+		ALOGE("readCnt = %d, respBuffer = %.2x\n", readCnt, respBuffer);
+
+	if (respBuffer == 1)
+		return 0;
+
+	return -1;
+}
+
+int uartSendBinaryFile(int uart_fd, const char* img)
+{
+	int ret = -1, write_size;
+	int i = 0;
+	ALOGE("voiceproc_uart_sendImg %s\n", img);
+	struct voiceproc_img fwimg;
+	char char_tmp = 0;
+	unsigned char local_vpimg_buf[VOICEPROC_MAX_FW_SIZE], *ptr = local_vpimg_buf;
+	int rc = 0, fw_fd = -1;
+	ssize_t nr;
+	size_t remaining;
+	struct stat fw_stat;
+
+	fw_fd = open(img, O_RDONLY);
+	if (fw_fd < 0) {
+		ALOGE("Fail to open %s\n", img);
+              rc = -1;
+		goto ld_img_error;
+	}
+
+	rc = fstat(fw_fd, &fw_stat);
+	if (rc < 0) {
+		ALOGE("Cannot stat file %s: %s\n", img, strerror(errno));
+              rc = -1;
+		goto ld_img_error;
+	}
+
+	remaining = (int)fw_stat.st_size;
+
+	ALOGV("Firmware %s size %d\n", img, remaining);
+
+	if (remaining > sizeof(local_vpimg_buf)) {
+		ALOGE("File %s size %d exceeds internal limit %d\n",
+			 img, remaining, sizeof(local_vpimg_buf));
+              rc = -1;
+		goto ld_img_error;
+	}
+
+	while (remaining) {
+		nr = read(fw_fd, ptr, remaining);
+		if (nr < 0) {
+			ALOGE("Error reading firmware: %s\n", strerror(errno));
+                     rc=-1;
+			goto ld_img_error;
+		} else if (!nr) {
+			if (remaining)
+				ALOGV("EOF reading firmware %s while %d bytes remain\n",
+					 img, remaining);
+			break;
+		}
+		remaining -= nr;
+		ptr += nr;
+	}
+
+	close (fw_fd);
+	fw_fd = -1;
+
+	fwimg.buf = local_vpimg_buf;
+	fwimg.img_size = (int)(fw_stat.st_size - remaining);
+	ALOGV("voiceproc_uart_sendImg firmware Total %d bytes\n", fwimg.img_size);
+	i = 0;
+	write_size = 0;
+
+	while (i < fwimg.img_size) {
+		ret = write(uart_fd, fwimg.buf+i,
+			(fwimg.img_size - i) < BUFSIZE_UART ? (fwimg.img_size-i) : BUFSIZE_UART);
+		if (ret == -1)
+              {
+			ALOGV("Error, voiceproc uart write: %s\n", strerror(errno));
+                     rc = -1;
+                     goto ld_img_error;
+              }
+
+		write_size += ret;
+		i += BUFSIZE_UART;
+	}
+	if (write_size != fwimg.img_size)
+       {
+		ALOGE("Error, UART writeCnt %d != img_size %d\n", write_size, fwimg.img_size);
+              rc = -1;
+              goto ld_img_error;
+       }
+	else
+		ALOGV("UART writeCnt is %d verus img_size is %d\n", write_size, fwimg.img_size);
+
+ld_img_error:
+	if (fw_fd >= 0)
+		close(fw_fd);
+	return rc;
+}
+
+#define UART_INIT_IMAGE "/system/etc/firmware/voiceproc_init.img"
+#define UART_DEV_NAME "/dev/ttyHS2"
+int uart_load_binary(int fd, char *firmware_path)
+{
+    int ret = 0;
+    int uart_fd = 0;
+    int i;
+    int retry_count = 100;
+    struct termios options;
+    struct termios2 options2;
+
+    while (retry_count) {
+        ret = ioctl(fd, ES310_RESET_CMD);
+        if (!ret)
+            ALOGV("ES310: voiceproc_reset ES310_RESET_CMD OK\n");
+        else
+            ALOGE("ES310: voiceproc_reset ES310_RESET_CMD error %s\n", strerror(errno));
+
+        /* init uart port */
+        uart_fd = open(UART_DEV_NAME, O_RDWR | O_NOCTTY | O_NDELAY);
+        if (uart_fd < 0) {
+            ALOGE("fail to open uart port %s\n", UART_DEV_NAME);
+            return -1;
+        }
+        fcntl(uart_fd, F_SETFL, 0);
+
+        /* First stage download */
+        setHigherBaudrate(uart_fd, 28800);
+
+        /* reset voice processor */
+        usleep(10000);
+
+        ret = sendDownloadCmd(uart_fd);
+        if (ret) {
+            ALOGE("error sending 1st download command on 1st stage\n");
+            retry_count--;
+            close(uart_fd);
+            continue;
+        }
+
+        uartSendBinaryFile(uart_fd, UART_INIT_IMAGE);
+        ALOGV("Send init image done\n");
+
+        /* Second stage download */
+        if (tcgetattr(uart_fd, &options) < 0) {
+            ALOGE("Can't get port settings\n");
+            retry_count--;
+            close(uart_fd);
+            continue;
+        } else if (tcsetattr(uart_fd, TCSADRAIN, &options) < 0) {
+            ALOGE("Can't set port settings\n");
+            retry_count--;
+            close(uart_fd);
+            continue;
+        }
+        if (ioctl(uart_fd, TCGETS2, &options2) < 0) {
+            ALOGE("Can't get port settings 2\n");
+            retry_count--;
+            close(uart_fd);
+            continue;
+        } else {
+            options2.c_cflag &= ~CBAUD;
+            options2.c_cflag |= BOTHER;
+            options2.c_ospeed = 3000000;
+            options2.c_ispeed = 3000000;
+            if (ioctl(uart_fd, TCSETS2, &options2) < 0) {
+                ALOGE("Can't set port settings 2\n");
+                retry_count--;
+                close(uart_fd);
+                continue;
+            }
+        }
+
+        usleep(10000);
+        ret = sendDownloadCmd(uart_fd);
+        if (ret) {
+            ALOGE("ES310: error sending download command, abort. \n");
+            ALOGE("ES310: retry_count:%d", 100 - retry_count);
+            retry_count--;
+            close(uart_fd);
+            continue;
+        } else {
+            ALOGV("ES310: init send command done");
+            break;
+        }
+    }
+
+    if (ret) {
+        ALOGE("ES310: initial codec command error");
+        ret = -1;
+        goto ERROR;
+    }
+
+    usleep(1000);
+    ret = uartSendBinaryFile(uart_fd, firmware_path);
+
+ERROR:
+    close(uart_fd);
+
+    return ret;
+}
+
+void *AudioHardwareALSA::CSDInitThreadWrapper(void *me) {
+    ALOGV("AudioHardwareALSA::CSDInitThread+");
+    csd_client_init();
+    ALOGV("AudioHardwareALSA::CSDInitThread-");
+    return NULL;
+}
+
+void *AudioHardwareALSA::AudienceThreadWrapper(void *me) {
+    static_cast<AudioHardwareALSA *>(me)->AudienceThreadEntry();
+    return NULL;
+}
+
+void AudioHardwareALSA::AudienceThreadEntry() {
+    ALOGV("AudioHardwareALSA::AudienceThreadEntry +");
+    pid_t tid  = gettid();
+    int err;
+    androidSetThreadPriority(tid, ANDROID_PRIORITY_AUDIO);
+    mAudienceCmd = CMD_AUDIENCE_READY;
+    while(!mKillAudienceThread) {
+        switch (mAudienceCmd)
+        {
+            case CMD_AUDIENCE_WAKEUP:
+            {
+                ALOGV("AudioHardwareALSA::AudienceThreadEntry, doAudienceCodec_Wakeup");
+                err = doAudienceCodec_Wakeup();
+                if (err < 0) {
+                    ALOGE("doAudienceCodec_Wakeup: error %d\n", err);
+                }
+                break;
+            }
+            default:
+                mAudienceCmd = CMD_AUDIENCE_READY;
+        }
+        mAudienceCmd = CMD_AUDIENCE_READY;
+        pthread_mutex_lock(&mAudienceMutex);
+        pthread_cond_wait(&mAudienceCV, &mAudienceMutex);
+        pthread_mutex_unlock(&mAudienceMutex);
+        ALOGV("Audience command:%d", mAudienceCmd);
+        continue;
+    }
+    ALOGV("ALSADevice::csdThreadEntry -");
+}
+
+status_t AudioHardwareALSA::doAudienceCodec_Init(void)
+{
+    int fd_codec = -1;
+    int rc = 0;
+    int Audio_path = ES310_PATH_SUSPEND;
+    int retry_count = 20;
+    static const char *const path = "/dev/audience_es310";
+
+    fd_codec = open("/dev/audience_es310", O_RDWR | O_NONBLOCK, 0);
+
+    if (fd_codec < 0) {
+        ALOGE("Cannot open %s %d.\n", path, fd_codec);
+            return fd_codec;
+    }
+
+    while(retry_count)
+    {
+        ALOGV("start loading the voiceproc.img file, retry:%d +", 20 - retry_count);
+        ALOGV("set codec reset command");
+        rc = uart_load_binary(fd_codec, "/etc/firmware/voiceproc.img");
+        if (rc != 0)
+        {
+            ALOGE("uart_load_binary fail, rc:%d", rc);
+            retry_count--;
+            continue;
+        }
+        ALOGV("start loading the voiceproc.img file -");
+        usleep(11000);
+        ALOGV("ES310 SYNC CMD +");
+        rc = ioctl(fd_codec, ES310_SYNC_CMD, NULL);
+        ALOGV("ES310 SYNC CMD, rc:%d-", rc);
+        if (rc != 0)
+        {
+            ALOGE("ES310 SYNC CMD fail, rc:%d", rc);
+            retry_count--;
+            continue;
+        }
+
+        if (rc == 0)
+            break;
+    }
+
+    pthread_mutex_init(&mAudienceMutex, NULL);
+    pthread_cond_init (&mAudienceCV, NULL);
+    mKillAudienceThread = false;
+    mAudienceCmd = CMD_AUDIENCE_READY;
+    ALOGV("Creating Audience Thread");
+    pthread_create(&AudienceThread, NULL, AudienceThreadWrapper, this);
+
+    if (rc == 0) {
+        ALOGV("audience codec init OK\n");
+        mAudienceCodecInit = 1;
+    } else
+        ALOGE("audience codec init failed\n");
+
+    close(fd_codec);
+    return rc;
+}
+
+status_t AudioHardwareALSA::doAudienceCodec_DeInit(void)
+{
+    mKillAudienceThread = true;
+    pthread_cond_signal(&mAudienceCV);
+    pthread_join(AudienceThread,NULL);
+    ALOGV("Audience Thread Killed");
+    return 0;
+}
+
+status_t AudioHardwareALSA::doAudienceCodec_Wakeup()
+{
+    int fd_codec = -1;
+    int retry = 4;
+    int rc = 0;
+    ALOGV("Pre Wakeup Audience Codec ++");
+    Mutex::Autolock lock(mAudioCodecLock);
+    if (fd_codec < 0) {
+        fd_codec = open("/dev/audience_es310", O_RDWR);
+        if (fd_codec < 0) {
+            ALOGE("Cannot open either audience_es310 device (%d)\n", fd_codec);
+            return -1;
+        }
+    }
+
+    retry = 4;
+    do {
+        ALOGV("ioctl ES310_SET_CONFIG retry:%d", 4-retry);
+        rc = ioctl(fd_codec, ES310_WAKEUP_CMD, NULL);
+        if (rc == 0) {
+            break;
+        }
+        else {
+            ALOGE("ERROR: ES310_SET_CONFIG rc=%d", rc);
+        }
+    } while (--retry);
+
+    close(fd_codec);
+    fd_codec = -1;
+
+    ALOGV("Pre Wakeup Audience Codec --");
+    return rc;
+}
+
+status_t AudioHardwareALSA::doRouting_Audience_Codec(int mode, int device, bool enable)
+{
+    int rc = 0;
+    int retry = 4;
+    int fd_codec = -1;
+    bool bVideoRecord_NS = false;
+    bool bPresetAgain = false;
+    bool bForcePathAgain = false;
+    bool bVRMode = false;
+    char cVRMode[255]="0";
+    char cVNRMode[255]="2";
+    int VNRMode = 2;
+
+    if (mAudienceCodecInit != 1) {
+        ALOGE("Audience Codec not initialized.\n");
+        return -1;
+    }
+
+    ALOGD("doRouting_Audience_Codec mode:%d Routes:0x%x Enable:%d.\n", mode, device, enable);
+
+    Mutex::Autolock lock(mAudioCodecLock);
+    if ((mode < AUDIO_MODE_CURRENT) || (mode > AUDIO_MODE_CNT)) {
+        ALOGW("Illegal value: doRouting_Audience_Codec(%d, 0x%x, %d)", mode, device, enable);
+        return -1;
+    }
+
+    if (enable == 0)
+    {
+        dwNewPath = ES310_PATH_SUSPEND;
+        goto ROUTE;
+    }
+
+    if (((device & AudioSystem::DEVICE_IN_ALL) == 0) &&
+        ((device & AudioSystem::DEVICE_OUT_ALL) != 0) &&
+        (mode == AUDIO_MODE_NORMAL))
+    {
+        ALOGV("doRouting_Audience_Codec: Normal mode, RX no routing ");
+        return 0;
+    }
+
+    property_get("audio.record.vrmode",cVRMode,"0");
+    if (!strncmp("1", cVRMode, 1)) {
+        bVRMode = 1;
+    } else {
+        bVRMode = 0;
+    }
+
+    property_get("persist.audio.vns.mode",cVNRMode,"2");
+    if (!strncmp("1", cVNRMode, 1)) {
+        VNRMode = 1;
+    } else {
+        VNRMode = 2;
+    }
+
+    ALOGV("doRouting_Audience_Codec  -> VRMode:%d, VNRMode:%d", bVRMode, VNRMode);
+
+    if (mode == AUDIO_MODE_IN_CALL ||
+         mode == AUDIO_MODE_RINGTONE) {
+        switch (device & AudioSystem::DEVICE_OUT_ALL) {
+            case AudioSystem::DEVICE_OUT_EARPIECE:
+                 dwNewPath = ES310_PATH_HANDSET;
+                 dwNewPreset = ES310_PRESET_HANDSET_INCALL_NB;
+                 break;
+            case AudioSystem::DEVICE_OUT_SPEAKER:
+                 dwNewPath = ES310_PATH_HANDSFREE;
+                 dwNewPreset = ES310_PRESET_HANDSFREE_INCALL_NB;
+                 break;
+            case AudioSystem::DEVICE_OUT_WIRED_HEADSET:
+                 dwNewPath = ES310_PATH_HEADSET;
+                 dwNewPreset = ES310_PRESET_HEADSET_INCALL_NB;
+                 break;
+            case AudioSystem::DEVICE_OUT_WIRED_HEADPHONE:
+                 dwNewPath = ES310_PATH_HANDSET;
+                 dwNewPreset = ES310_PRESET_HANDSET_INCALL_NB;
+                 break;
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_SCO:
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT:
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP:
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES:
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER:
+                 dwNewPath = ES310_PATH_HANDSET;
+                 dwNewPreset = ES310_PRESET_HANDSET_INCALL_NB;
+                 break;
+            case AudioSystem::DEVICE_OUT_AUX_DIGITAL:
+            case AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET:
+            case AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET:
+                 dwNewPath = ES310_PATH_HEADSET;
+                 dwNewPreset = ES310_PRESET_HEADSET_INCALL_NB;
+                 break;
+            default:
+                 dwNewPath = ES310_PATH_HANDSET;
+                 dwNewPreset = ES310_PRESET_HANDSET_INCALL_NB;
+                 break;
+        }
+        goto ROUTE;
+    }
+    else if (mode == AUDIO_MODE_IN_COMMUNICATION) {
+        switch (device & AudioSystem::DEVICE_OUT_ALL) {
+            case AudioSystem::DEVICE_OUT_EARPIECE:
+                 dwNewPath = ES310_PATH_HANDSET;
+                 dwNewPreset = ES310_PRESET_HANDSET_VOIP_WB;
+                 break;
+            case AudioSystem::DEVICE_OUT_SPEAKER:
+                 dwNewPath = ES310_PATH_HANDSFREE;
+                 dwNewPreset = ES310_PRESET_HANDSFREE_VOIP_WB;
+                 break;
+            case AudioSystem::DEVICE_OUT_WIRED_HEADSET:
+                 dwNewPath = ES310_PATH_HEADSET;
+                 dwNewPreset = ES310_PRESET_HEADSET_VOIP_WB;
+                 break;
+            case AudioSystem::DEVICE_OUT_WIRED_HEADPHONE:
+                 dwNewPath = ES310_PATH_HANDSET;
+                 dwNewPreset = ES310_PRESET_HANDSET_VOIP_WB;
+                 break;
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_SCO:
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET:
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT:
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP:
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES:
+            case AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER:
+                 dwNewPath = ES310_PATH_HANDSET;
+                 dwNewPreset = ES310_PRESET_HANDSET_VOIP_WB;
+                 break;
+            case AudioSystem::DEVICE_OUT_AUX_DIGITAL:
+            case AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET:
+            case AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET:
+                 dwNewPath = ES310_PATH_HEADSET;
+                 dwNewPreset = ES310_PRESET_HEADSET_VOIP_WB;
+                 break;
+            default:
+                 dwNewPath = ES310_PATH_HANDSET;
+                 dwNewPreset = ES310_PRESET_HANDSET_VOIP_WB;
+                 break;
+        }
+        goto ROUTE;
+    }
+    else {
+        switch (device & AudioSystem::DEVICE_IN_ALL)
+        {
+                //TX
+                case AudioSystem::DEVICE_IN_COMMUNICATION:
+                     dwNewPath = ES310_PATH_HANDSFREE;
+                     dwNewPreset = ES310_PRESET_HANDSFREE_REC_WB;
+                     break;
+                case AudioSystem::DEVICE_IN_AMBIENT:
+                     dwNewPath = ES310_PATH_HANDSFREE;
+                     dwNewPreset = ES310_PRESET_HANDSFREE_REC_WB;
+                     break;
+                case AudioSystem::DEVICE_IN_BUILTIN_MIC:
+                     {
+                         dwNewPath = ES310_PATH_HANDSET;
+                         dwNewPreset = ES310_PRESET_ANALOG_BYPASS;
+                     }
+                     if (bVRMode)
+                     {
+                         dwNewPreset = ES310_PRESET_VOICE_RECOGNIZTION_WB;
+                     }
+                     break;
+                case AudioSystem::DEVICE_IN_BLUETOOTH_SCO_HEADSET:
+                     dwNewPath = ES310_PATH_HEADSET;
+                     dwNewPreset = ES310_PRESET_HANDSFREE_REC_WB;
+                     break;
+                case AudioSystem::DEVICE_IN_WIRED_HEADSET:
+                     dwNewPath = ES310_PATH_HEADSET;
+                     dwNewPreset = ES310_PRESET_HEADSET_MIC_ANALOG_BYPASS;
+                     break;
+                case AudioSystem::DEVICE_IN_AUX_DIGITAL:
+                case AudioSystem::DEVICE_IN_VOICE_CALL:
+                case AudioSystem::DEVICE_IN_BACK_MIC:
+                     dwNewPath = ES310_PATH_HANDSET;
+                     dwNewPreset = ES310_PRESET_HANDSFREE_REC_WB;
+                     break;
+                default:
+                     dwNewPath = ES310_PATH_HANDSET;
+                     dwNewPreset = ES310_PRESET_HANDSFREE_REC_WB;
+                     break;
+        }
+    }
+
+ROUTE:
+
+    if (VNRMode == 1) {
+        ALOGE("Switch to 1-Mic Solution");
+        if (dwNewPreset == ES310_PRESET_HANDSET_INCALL_NB) {
+            dwNewPreset = ES310_PRESET_HANDSET_INCALL_NB_1MIC;
+        }
+        if (dwNewPreset == ES310_PRESET_HANDSET_VOIP_WB) {
+            dwNewPreset = ES310_PRESET_HANDSET_INCALL_VOIP_WB_1MIC;
+        }
+    }
+
+    ALOGV("doRouting_Audience_Codec: dwOldPath=%d, dwNewPath=%d, prevMode=%d, mode=%d",
+                dwOldPath, dwNewPath, AudiencePrevMode, mode);
+
+    if (AudiencePrevMode != mode)
+    {
+        bForcePathAgain = true;
+        AudiencePrevMode = mode;
+    }
+
+    if (bForcePathAgain ||
+        (dwOldPath != dwNewPath) ||
+        (dwOldPreset != dwNewPreset)) {
+
+        if (fd_codec < 0) {
+            fd_codec = open("/dev/audience_es310", O_RDWR);
+            if (fd_codec < 0) {
+                ALOGE("Cannot open either audience_es310 device (%d)\n", fd_codec);
+                return -1;
+            }
+        }
+
+        if (bForcePathAgain ||
+            (dwOldPath != dwNewPath)) {
+            bPresetAgain = true;
+            retry = 4;
+            do {
+                ALOGV("ioctl ES310_SET_CONFIG newPath:%d, retry:%d", dwNewPath, (4-retry));
+                rc = ioctl(fd_codec, ES310_SET_CONFIG, &dwNewPath);
+
+                if (rc == 0) {
+                    dwOldPath = dwNewPath;
+                    break;
+                }
+                else
+                {
+                    ALOGE("ERROR: ES310_SET_CONFIG rc=%d", rc);
+                }
+            } while (--retry);
+            /*Close driver first incase we need to do audience HW reset when ES310_SET_CONFIG failed.*/
+        }
+
+        if (bPresetAgain)
+            ALOGV("doRouting_Audience_Codec: dwOldPreset:%s, dwNewPreset:%s", getNameByPresetID(dwOldPreset), getNameByPresetID(dwNewPreset));
+
+        if (bPresetAgain && (dwNewPath != ES310_PATH_SUSPEND)) {
+            retry = 4;
+            do {
+                ALOGV("ioctl ES310_SET_PRESET newPreset:0x%x, retry:%d", dwNewPreset, (4-retry));
+                rc = ioctl(fd_codec, ES310_SET_PRESET, &dwNewPreset);
+
+                if (rc == 0) {
+                    dwOldPreset = dwNewPreset;
+                    break;
+                }
+                else
+                {
+                    ALOGE("ERROR: ES310_SET_PRESET rc=%d", rc);
+                }
+            } while (--retry);
+            /*Close driver first incase we need to do audience HW reset when ES310_SET_CONFIG failed.*/
+        }
+
+        close(fd_codec);
+        fd_codec = -1;
+
+RECOVER:
+        if (rc < 0) {
+            ALOGE("E310 do hard reset to recover from error!\n");
+            rc = doAudienceCodec_Init(); /* A1026 needs to do hard reset! */
+            if (!rc) {
+                fd_codec = open("/dev/audience_es310", O_RDWR);
+                if (fd_codec >= 0) {
+                    rc = ioctl(fd_codec, ES310_SET_CONFIG, &dwNewPath);
+                    if (rc == NO_ERROR)
+                        dwOldPath = dwNewPath;
+                    else
+                        ALOGE("Audience Codec Fatal Error! rc %d\n", rc);
+                    close(fd_codec);
+                } else
+                    ALOGE("Audience Codec Fatal Error: Re-init Audience Codec open driver fail!! rc %d\n", fd_codec);
+            } else
+                ALOGE("Audience Codec Fatal Error: Re-init A1026 Failed. rc %d\n", rc);
+        }
+    }
+
+    return NO_ERROR;
+}
+char* AudioHardwareALSA::getNameByPresetID(int presetID)
+{
+     switch(presetID){
+        case ES310_PRESET_HANDSET_INCALL_NB:
+              return "ES310_PRESET_HANDSET_INCALL_NB";
+        case ES310_PRESET_HEADSET_INCALL_NB:
+              return "ES310_PRESET_HEADSET_INCALL_NB";
+        case ES310_PRESET_HANDSET_INCALL_NB_1MIC:
+              return "ES310_PRESET_HANDSET_INCALL_NB_1MIC";
+        case ES310_PRESET_HANDSFREE_INCALL_NB:
+              return "ES310_PRESET_HANDSFREE_INCALL_NB";
+        case ES310_PRESET_HANDSET_INCALL_WB:
+              return "ES310_PRESET_HANDSET_INCALL_WB";
+        case ES310_PRESET_HEADSET_INCALL_WB:
+              return "ES310_PRESET_HEADSET_INCALL_WB";
+        case ES310_PRESET_AUDIOPATH_DISABLE:
+              return "ES310_PRESET_AUDIOPATH_DISABLE";
+        case ES310_PRESET_HANDSFREE_INCALL_WB:
+              return "ES310_PRESET_HANDSFREE_INCALL_WB";
+        case ES310_PRESET_HANDSET_VOIP_WB:
+              return "ES310_PRESET_HANDSET_VOIP_WB";
+        case ES310_PRESET_HEADSET_VOIP_WB:
+              return "ES310_PRESET_HEADSET_VOIP_WB";
+        case ES310_PRESET_HANDSFREE_REC_WB:
+              return "ES310_PRESET_HANDSFREE_REC_WB";
+        case ES310_PRESET_HANDSFREE_VOIP_WB:
+              return "ES310_PRESET_HANDSFREE_VOIP_WB";
+        case ES310_PRESET_VOICE_RECOGNIZTION_WB:
+              return "ES310_PRESET_VOICE_RECOGNIZTION_WB";
+        case ES310_PRESET_HANDSET_INCALL_VOIP_WB_1MIC:
+              return "ES310_PRESET_HANDSET_INCALL_VOIP_WB_1MIC";
+        case ES310_PRESET_ANALOG_BYPASS:
+              return "ES310_PRESET_ANALOG_BYPASS";
+        case ES310_PRESET_HEADSET_MIC_ANALOG_BYPASS:
+              return "ES310_PRESET_HEADSET_MIC_ANALOG_BYPASS";
+        default:
+            return "Unknown";
+     }
+     return "Unknown";
+}
+#endif
+//XIAOMI_END
+
 status_t AudioHardwareALSA::setMicMute(bool state)
 {
     int newMode = mode();
diff --git a/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioHardwareALSA.h b/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioHardwareALSA.h
index d861d06..063708d 100644
--- a/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioHardwareALSA.h
+++ b/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioHardwareALSA.h
@@ -44,6 +44,65 @@ extern "C" {
 
 #include <hardware/hardware.h>
 
+//XIAOMI_START
+#ifdef USE_ES310
+#include <sys/ioctl.h>
+#include <fcntl.h>   /* File control definitions */
+#include <errno.h>   /* Error number definitions */
+#include <termios.h> /* POSIX terminal control definitions */
+
+#define A200_msg_Sync_Polling 0x80000000
+
+#define PRESET_BASE 0x80310000
+#define ES310_PRESET_HANDSET_INCALL_NB		    (PRESET_BASE)
+#define ES310_PRESET_HEADSET_INCALL_NB 	           (PRESET_BASE + 1)
+#define ES310_PRESET_HANDSET_INCALL_NB_1MIC	    (PRESET_BASE + 2)
+#define ES310_PRESET_HANDSFREE_INCALL_NB		    (PRESET_BASE + 3)
+#define ES310_PRESET_HANDSET_INCALL_WB	           (PRESET_BASE + 4)
+#define ES310_PRESET_HEADSET_INCALL_WB		    (PRESET_BASE + 5)
+#define ES310_PRESET_AUDIOPATH_DISABLE               (PRESET_BASE + 6)
+#define ES310_PRESET_HANDSFREE_INCALL_WB	    (PRESET_BASE + 7)
+#define ES310_PRESET_HANDSET_VOIP_WB		           (PRESET_BASE + 8)
+#define ES310_PRESET_HEADSET_VOIP_WB                   (PRESET_BASE + 9)
+#define ES310_PRESET_HANDSFREE_REC_WB                 (PRESET_BASE + 10)
+#define ES310_PRESET_HANDSFREE_VOIP_WB               (PRESET_BASE + 11)
+#define ES310_PRESET_VOICE_RECOGNIZTION_WB       (PRESET_BASE + 12)
+#define ES310_PRESET_HANDSET_INCALL_VOIP_WB_1MIC	(PRESET_BASE + 13)
+#define ES310_PRESET_ANALOG_BYPASS	                   (PRESET_BASE + 14)
+#define ES310_PRESET_HEADSET_MIC_ANALOG_BYPASS    (PRESET_BASE + 15)
+
+struct voiceproc_img
+{
+	unsigned char *buf;
+	unsigned img_size;
+};
+
+#define ES310_IOCTL_MAGIC ';'
+#define ES310_BOOTUP_INIT _IOW(ES310_IOCTL_MAGIC, 1, struct es310img *)
+#define ES310_SET_CONFIG _IOW(ES310_IOCTL_MAGIC, 2, unsigned int *)
+#define ES310_SET_PARAM _IOW(ES310_IOCTL_MAGIC, 4, struct ES310_config_data *)
+#define ES310_SYNC_CMD _IO(ES310_IOCTL_MAGIC, 9)
+#define ES310_SLEEP_CMD _IO(ES310_IOCTL_MAGIC, 11)
+#define ES310_RESET_CMD _IO(ES310_IOCTL_MAGIC, 12)
+#define ES310_WAKEUP_CMD _IO(ES310_IOCTL_MAGIC, 13)
+#define ES310_MDELAY _IOW(ES310_IOCTL_MAGIC, 14, unsigned int)
+#define ES310_READ_FAIL_COUNT _IOR(ES310_IOCTL_MAGIC, 15, unsigned int *)
+#define ES310_READ_SYNC_DONE _IOR(ES310_IOCTL_MAGIC, 16, bool *)
+#define ES310_READ_DATA _IOR(ES310_IOCTL_MAGIC, 17, unsigned long *)
+#define ES310_WRITE_MSG _IOW(ES310_IOCTL_MAGIC, 18, unsigned long)
+#define ES310_SET_PRESET _IOW(ES310_IOCTL_MAGIC, 19, unsigned long)
+
+enum ES310_PathID {
+        ES310_PATH_SUSPEND = 0,
+        ES310_PATH_HANDSET,
+        ES310_PATH_HEADSET,
+        ES310_PATH_HANDSFREE,
+        ES310_PATH_BACKMIC,
+        ES310_PATH_MAX
+};
+#endif
+//XIAOMI_END
+
 namespace android_audio_legacy
 {
 using android::List;
@@ -276,12 +335,52 @@ struct use_case_t {
 
 typedef List < use_case_t > ALSAUseCaseList;
 
+//XIAOMI_START
+#ifdef USE_ES310
+class CSDCommand
+{
+public:
+    CSDCommand(int command, int rx = 0, int tx = 0, uint32_t Flag = 0)
+    {
+        cmd = command;
+        rx_id = rx;
+        tx_id = tx;
+        devSetFlag = Flag;
+    };
+    int cmd;
+    int rx_id;
+    int tx_id;
+    uint32_t devSetFlag;
+};
+#endif
+//XIAOMI_END
+
 class ALSADevice
 {
 
 public:
-
+//XIAOMI_START
+#ifdef USE_ES310
+    static void *csdThreadWrapper(void *me);
+    void csdThreadEntry();
+    List <CSDCommand>  CSDCmdQueue;
+    pthread_t csdThread;
+    pthread_mutex_t m_csd_mutex;
+    pthread_cond_t m_csd_cv;
+    int m_csdCmd;
+    bool m_killcsdThread;
+    enum {
+        CMD_CSD_READY = -1,
+        CMD_CSD_START_VOICE = 0,
+        CMD_CSD_END_VOICE    = 1,
+        CMD_CSD_ENABLE_DEVICE = 2,
+        CMD_CSD_DISABLE_DEVICE = 3,
+    };
+    int mPrevDevice;
+    ALSADevice(AudioHardwareALSA* parent);
+#else
     ALSADevice();
+#endif
     virtual ~ALSADevice();
 //    status_t init(alsa_device_t *module, ALSAHandleList &list);
     status_t open(alsa_handle_t *handle);
@@ -329,6 +428,12 @@ public:
     bool mSSRComplete;
     int mCurDevice;
     long avail_in_ms;
+//XIAOMI_START
+#ifdef USE_ES310
+    friend class AudioHardwareALSA;
+    AudioHardwareALSA* mParent;
+#endif
+//XIAOMI_END
 protected:
     friend class AudioHardwareALSA;
 private:
@@ -854,6 +959,34 @@ public:
             AudioSystem::audio_in_acoustics acoustics);
     virtual    void        closeInputStream(AudioStreamIn* in);
 
+//XIAOMI_START
+#ifdef USE_ES310
+    static void *CSDInitThreadWrapper(void *me);//i dont know
+    pthread_t CSDInitThread; //i dont know
+    static void *AudienceThreadWrapper(void *me);
+    void AudienceThreadEntry();
+    pthread_t AudienceThread;
+    pthread_mutex_t mAudienceMutex;
+    pthread_cond_t mAudienceCV;
+    int mAudienceCmd;
+    bool mKillAudienceThread;
+    enum {
+        CMD_AUDIENCE_READY = -1,
+        CMD_AUDIENCE_WAKEUP = 0,
+    };
+    void enableAudienceloopback(int enable);
+    status_t doAudienceCodec_Init(void);
+    status_t doAudienceCodec_DeInit(void);
+    status_t doAudienceCodec_Wakeup(void);
+    status_t doRouting_Audience_Codec(int mode, int device, bool enable);
+    char* getNameByPresetID(int presetID);
+    uint32_t getCurDevice(){ return mCurDevice;};
+    int getCallState(){ return mVoiceCallState;};
+    bool    mAudienceCodecInit;
+    Mutex mAudioCodecLock;
+    int mLoopbackState;
+#endif
+//XIAOMI_END
     status_t    startPlaybackOnExtOut(uint32_t activeUsecase);
     status_t    stopPlaybackOnExtOut(uint32_t activeUsecase);
     status_t    setProxyProperty(uint32_t value);
diff --git a/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioStreamOutALSA.cpp b/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioStreamOutALSA.cpp
index 0db5649..63f5764 100644
--- a/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioStreamOutALSA.cpp
+++ b/hardware/qcom/audio-caf/msm8960/legacy/alsa_sound/AudioStreamOutALSA.cpp
@@ -222,6 +222,7 @@ ssize_t AudioStreamOutALSA::write(const void *buffer, size_t bytes)
             if (! (mParent->getExtOutActiveUseCases_l() & mUseCase )){
                 ALOGD("startPlaybackOnExtOut_l from write :: useCase = %s", mHandle->useCase);
                 status_t err = NO_ERROR;
+                if (mParent->mode() != AudioSystem::MODE_IN_CALL)
                 err = mParent->startPlaybackOnExtOut_l(mUseCase);
                 if(err) {
                     ALOGE("startPlaybackOnExtOut_l from write return err = %d", err);
diff --git a/hardware/qcom/audio-caf/msm8960/legacy/libalsa-intf/alsa_ucm.h b/hardware/qcom/audio-caf/msm8960/legacy/libalsa-intf/alsa_ucm.h
index ef64074..e730492 100644
--- a/hardware/qcom/audio-caf/msm8960/legacy/libalsa-intf/alsa_ucm.h
+++ b/hardware/qcom/audio-caf/msm8960/legacy/libalsa-intf/alsa_ucm.h
@@ -126,7 +126,11 @@ extern "C" {
 #define SND_USE_CASE_DEV_HDMI		"HDMI"
 #define SND_USE_CASE_DEV_DOCK		"Dock"
 /* add new devices to end of list */
+#if defined(USE_ES310) || defined(TAURUS)
+#undef SND_USE_CASE_DEV_HEADSET
 
+#define SND_USE_CASE_DEV_HEADSET       "HeadsetMic TX"
+#endif
 
 /*
  * Use Case Modifiers.
diff --git a/hardware/qcom/audio-caf/msm8960/legacy/libalsa-intf/msm8960_use_cases.h b/hardware/qcom/audio-caf/msm8960/legacy/libalsa-intf/msm8960_use_cases.h
index fd1ccc9..3a97efd 100644
--- a/hardware/qcom/audio-caf/msm8960/legacy/libalsa-intf/msm8960_use_cases.h
+++ b/hardware/qcom/audio-caf/msm8960/legacy/libalsa-intf/msm8960_use_cases.h
@@ -318,6 +318,27 @@ static card_mapping_t card_mapping_list[] = {
 #define SND_USE_CASE_DEV_VOIP_LINE          "VOIP Line"
 #define SND_USE_CASE_DEV_VOIP_HANDSET       "VOIP Handset"
 
+#if defined(USE_ES310) || defined(TAURUS)
+#undef SND_USE_CASE_DEV_VOC_EARPIECE
+#undef SND_USE_CASE_DEV_VOC_HEADPHONE
+#undef SND_USE_CASE_DEV_VOC_SPEAKER
+#undef SND_USE_CASE_DEV_VOC_LINE
+#undef SND_USE_CASE_DEV_VOIP_EARPIECE
+#undef SND_USE_CASE_DEV_VOIP_HEADPHONE
+#undef SND_USE_CASE_DEV_VOIP_SPEAKER
+
+#define SND_USE_CASE_DEV_VOC_EARPIECE "Handset VoiceProc"
+#define SND_USE_CASE_DEV_VOC_HEADPHONE "Headset VoiceProc"
+#define SND_USE_CASE_DEV_VOC_SPEAKER "Handfree VoiceProc"
+#define SND_USE_CASE_DEV_VOC_LINE "Line Voice"
+#define SND_USE_CASE_DEV_VOIP_EARPIECE "Handset VOIP VoiceProc"
+#define SND_USE_CASE_DEV_VOIP_HEADPHONE "Headset VOIP VoiceProc"
+#define SND_USE_CASE_DEV_VOIP_SPEAKER "Handfree VOIP VoiceProc"
+#define SND_USE_CASE_DEV_VOC_LINE_BACK "Line BackMic Voice"
+#define SND_USE_CASE_DEV_LINE_MAIN "Line Main"
+#define SND_USE_CASE_DEV_VOC_HEADSET_MIC "HeadsetMic Voice TX"
+#endif
+
 #define SND_USE_CASE_MOD_PLAY_FM         "Play FM"
 #define SND_USE_CASE_MOD_CAPTURE_FM      "Capture FM"
 #define SND_USE_CASE_MOD_CAPTURE_LOWLATENCY_MUSIC     "Capture Lowlatency Music"


project packages/apps/Settings/
diff --git a/packages/apps/Settings/res/values-zh-rCN/strings.xml b/packages/apps/Settings/res/values-zh-rCN/strings.xml
index 3f10b5f..f6a6f86 100644
--- a/packages/apps/Settings/res/values-zh-rCN/strings.xml
+++ b/packages/apps/Settings/res/values-zh-rCN/strings.xml
@@ -2407,6 +2407,7 @@
     <string name="lock_screen_notifications_interstitial_message" msgid="6164532459432182244">"在设备锁定时，您希望通知如何显示？"</string>
     <string name="app_notifications_title" msgid="5810577805218003760">"应用通知"</string>
     <string name="other_sound_settings" msgid="3151004537006844718">"其他提示音"</string>
+    <string name="dolby_sound_settings">"杜比音效"</string>
     <string name="dial_pad_tones_title" msgid="1999293510400911558">"拨号键盘提示音"</string>
     <string name="screen_locking_sounds_title" msgid="1340569241625989837">"屏幕锁定提示音"</string>
     <string name="docking_sounds_title" msgid="155236288949940607">"基座提示音"</string>
diff --git a/packages/apps/Settings/res/values-zh-rHK/strings.xml b/packages/apps/Settings/res/values-zh-rHK/strings.xml
index 0b00fdd..85954f4 100644
--- a/packages/apps/Settings/res/values-zh-rHK/strings.xml
+++ b/packages/apps/Settings/res/values-zh-rHK/strings.xml
@@ -2408,6 +2408,7 @@
     <string name="lock_screen_notifications_interstitial_message" msgid="6164532459432182244">"當裝置鎖定時，您要如何顯示通知？"</string>
     <string name="app_notifications_title" msgid="5810577805218003760">"應用程式通知"</string>
     <string name="other_sound_settings" msgid="3151004537006844718">"其他音效"</string>
+    <string name="dolby_sound_settings">"杜比音效"</string>
     <string name="dial_pad_tones_title" msgid="1999293510400911558">"撥號鍵盤音效"</string>
     <string name="screen_locking_sounds_title" msgid="1340569241625989837">"螢幕鎖定音效"</string>
     <string name="docking_sounds_title" msgid="155236288949940607">"插座音效"</string>
diff --git a/packages/apps/Settings/res/values-zh-rTW/strings.xml b/packages/apps/Settings/res/values-zh-rTW/strings.xml
index 8760a87..e284131 100644
--- a/packages/apps/Settings/res/values-zh-rTW/strings.xml
+++ b/packages/apps/Settings/res/values-zh-rTW/strings.xml
@@ -2408,6 +2408,7 @@
     <string name="lock_screen_notifications_interstitial_message" msgid="6164532459432182244">"當裝置鎖定時，您要如何顯示通知？"</string>
     <string name="app_notifications_title" msgid="5810577805218003760">"應用程式通知"</string>
     <string name="other_sound_settings" msgid="3151004537006844718">"其他音效"</string>
+    <string name="dolby_sound_settings">"杜比音效"</string>
     <string name="dial_pad_tones_title" msgid="1999293510400911558">"撥號鍵盤音效"</string>
     <string name="screen_locking_sounds_title" msgid="1340569241625989837">"螢幕鎖定音效"</string>
     <string name="docking_sounds_title" msgid="155236288949940607">"固定音效"</string>
diff --git a/packages/apps/Settings/res/values/strings.xml b/packages/apps/Settings/res/values/strings.xml
index cef6bc8..0e39a7d 100644
--- a/packages/apps/Settings/res/values/strings.xml
+++ b/packages/apps/Settings/res/values/strings.xml
@@ -5738,6 +5738,7 @@
 
     <!-- Sound & notification > Sound section: Title for the other sounds option and associated settings page. [CHAR LIMIT=30] -->
     <string name="other_sound_settings">Other sounds</string>
+    <string name="dolby_sound_settings">dolby_sounds</string>
 
     <!-- Sound & notification > Other sounds: Title for the option enabling touch sounds for dial pad tones. [CHAR LIMIT=30] -->
     <string name="dial_pad_tones_title">Dial pad tones</string>
diff --git a/packages/apps/Settings/res/xml/sounds.xml b/packages/apps/Settings/res/xml/sounds.xml
index c94ac84..6a8977b 100644
--- a/packages/apps/Settings/res/xml/sounds.xml
+++ b/packages/apps/Settings/res/xml/sounds.xml
@@ -104,6 +104,11 @@
                 android:fragment="com.android.settings.notification.OtherSoundSettings" />
     </PreferenceCategory>
 
+        <!-- Dolby sounds -->
+    <PreferenceScreen android:title="@string/dolby_sound_settings" android:key="dolby_sounds">
+        <intent android:targetPackage="com.dolby.ds1appUI" android:action="android.intent.action.MAIN" android:targetClass="com.dolby.ds1appUI.MainActivity" />
+    </PreferenceScreen>
+
     <PreferenceCategory
             android:key="vibrate"
             android:title="@string/category_vibrate">

project vendor/mk/
diff --git a/vendor/mk/config/common.mk b/vendor/mk/config/common.mk
index 3ecd738..8ed30b2 100644
--- a/vendor/mk/config/common.mk
+++ b/vendor/mk/config/common.mk
@@ -147,7 +147,6 @@ PRODUCT_PACKAGES += \
 PRODUCT_PACKAGES += \
     Launcher3 \
     MoKeeLauncher \
-    AudioFX \
     CMFileManager \
     Eleven \
     LockClock \
